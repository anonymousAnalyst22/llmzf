###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               26/Sep/2023  15:48:34
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\fuzzing-coordinator\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW246C.tmp
#        (D:\fuzzing-coordinator\Components\stack\zcl\zcl_general.c -D SECURE=1
#        -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D MULTICAST_ENABLED=FALSE
#        -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY
#        -D ZCL_POLL_CONTROL -D ISR_KEYINTERRUPT -D HAL_UART=TRUE -D
#        HAL_LCD=FALSE -D ZCL_ON_OFF -D INT_HEAP_LEN=3000 -D
#        HAL_UART_DMA_RX_MAX=128 -D HAL_UART_DMA_TX_MAX=128 -lC
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
#        -lA
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x00, 0x01, 0x02, 0x03,
#        0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
#        0x0F}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
#        -DENABLE_LED4_DISABLE_S1) -f
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\Common\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\SPI\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\Font\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_LCD_SPI\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_OLED\
#        -I
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_TFT\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List\zcl_general.lst
#    Object file        =  
#        D:\fuzzing-coordinator\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj\zcl_general.r51
#
###############################################################################

D:\fuzzing-coordinator\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "zcl.h"
     46          #include "zcl_general.h"
     47          #include "zcl_closures.h"
     48          //#include "ZDApp.h"
     49          
     50          #include <stdio.h>
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          #include "bdb.h"
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     61          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     62          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     63          
     64          #ifdef ZCL_SCENES
     65          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     66          #endif // ZCL_SCENES
     67          
     68          /*********************************************************************
     69           * CONSTANTS
     70           */
     71          
     72          /*********************************************************************
     73           * TYPEDEFS
     74           */
     75          typedef struct zclGenCBRec
     76          {
     77            struct zclGenCBRec        *next;
     78            uint8                     endpoint; // Used to link it into the endpoint descriptor
     79            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     80          } zclGenCBRec_t;
     81          
     82          typedef struct zclGenSceneItem
     83          {
     84            struct zclGenSceneItem    *next;
     85            uint8                     endpoint; // Used to link it into the endpoint descriptor
     86            zclGeneral_Scene_t        scene;    // Scene info
     87          } zclGenSceneItem_t;
     88          
     89          typedef struct zclGenAlarmItem
     90          {
     91            struct zclGenAlarmItem    *next;
     92            uint8                     endpoint; // Used to link it into the endpoint descriptor
     93            zclGeneral_Alarm_t        alarm;    // Alarm info
     94          } zclGenAlarmItem_t;
     95          
     96          // Scene NV types
     97          typedef struct
     98          {
     99            uint16                    numRecs;
    100          } nvGenScenesHdr_t;
    101          
    102          typedef struct zclGenSceneNVItem
    103          {
    104            uint8                     endpoint;
    105            zclGeneral_Scene_t        scene;
    106          } zclGenSceneNVItem_t;
    107          
    108          /*********************************************************************
    109           * GLOBAL VARIABLES
    110           */
    111          
    112          /*********************************************************************
    113           * GLOBAL FUNCTIONS
    114           */
    115          
    116          /*********************************************************************
    117           * LOCAL VARIABLES
    118           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    119          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    120          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    121          
    122          #if defined( ZCL_SCENES )
    123            #if !defined ( ZCL_STANDALONE )
    124              static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    125            #endif
    126          #endif // ZCL_SCENES
    127          
    128          #ifdef ZCL_ALARMS
    129          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    130          #endif // ZCL_ALARMS
    131          
    132          /*********************************************************************
    133           * LOCAL FUNCTIONS
    134           */
    135          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    136          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    137          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    138          
    139          // Device Configuration and Installation clusters
    140          #ifdef ZCL_BASIC
    141          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    142          #endif // ZCL_BASIC
    143          
    144          #ifdef ZCL_IDENTIFY
    145          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    146          #endif // ZCL_IDENTIFY
    147          static ZStatus_t zclGeneral_ProcessInIdentityJC( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    148          
    149          // Groups and Scenes clusters
    150          #ifdef ZCL_GROUPS
    151          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    152          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    153          #endif // ZCL_GROUPS
    154          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    155          
    156          #ifdef ZCL_SCENES
    157          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    158          #endif // ZCL_SCENES
    159          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    160          
    161          // On/Off and Level Control Configuration clusters
    162          #ifdef ZCL_ON_OFF
    163          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    164          #endif // ZCL_ONOFF
    165          
    166          #ifdef ZCL_LEVEL_CTRL
    167          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    168          #endif // ZCL_LEVEL_CTRL
    169          
    170          // Alarms cluster
    171          #ifdef ZCL_ALARMS
    172          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    173          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    174          #endif // ZCL_ALARMS
    175          
    176          // Location cluster
    177          #ifdef ZCL_LOCATION
    178          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    179          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    180          #endif // ZCL_LOCATION
    181          
    182          #ifdef ZCL_SCENES
    183            #if !defined ( ZCL_STANDALONE )
    184              static uint8 zclGeneral_ScenesInitNV( void );
    185              static void zclGeneral_ScenesSetDefaultNV( void );
    186              static void zclGeneral_ScenesWriteNV( void );
    187              static uint16 zclGeneral_ScenesRestoreFromNV( void );
    188            #endif
    189          #endif // ZCL_SCENES
    190          
    191          /*********************************************************************
    192           * @fn      zclGeneral_RegisterCmdCallbacks
    193           *
    194           * @brief   Register an applications command callbacks
    195           *
    196           * @param   endpoint - application's endpoint
    197           * @param   callbacks - pointer to the callback record.
    198           *
    199           * @return  ZMemError if not able to allocate
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    202          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
    203            zclGenCBRec_t *pNewItem;
    204            zclGenCBRec_t *pLoop;
    205          
    206            // Register as a ZCL Plugin
    207            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7021         JNZ       ??zclGeneral_RegisterCmdCallbacks_0
    208            {
    209              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    210                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    211                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV       ?V2,#`??zclGeneral_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV       ?V3,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV       R0,#?V2
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV       R4,#0x14
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7A00         MOV       R2,#0x0
   \   000022   7B00         MOV       R3,#0x0
   \   000024   12....       LCALL     `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
    212          
    213          #ifdef ZCL_SCENES
    214              // Initialize the Scenes Table
    215              zclGeneral_ScenesInit();
    216          #endif // ZCL_SCENES
    217          
    218              zclGenPluginRegisted = TRUE;
   \   00002C   90....       MOV       DPTR,#zclGenPluginRegisted
   \   00002F   7401         MOV       A,#0x1
   \   000031   F0           MOVX      @DPTR,A
    219            }
    220          
    221            // Fill in the new profile list
    222            pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV       R2,#0x5
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV       ?V2,R2
   \   00003B   8B..         MOV       ?V3,R3
   \   00003D   A8..         MOV       R0,?V2
   \   00003F   A9..         MOV       R1,?V3
    223            if ( pNewItem == NULL )
   \   000041   E8           MOV       A,R0
   \   000042   49           ORL       A,R1
   \   000043   7004         JNZ       ??zclGeneral_RegisterCmdCallbacks_1
    224              return (ZMemError);
   \   000045   7910         MOV       R1,#0x10
   \   000047   8025         SJMP      ??zclGeneral_RegisterCmdCallbacks_2
    225          
    226            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000049   12....       LCALL     ?Subroutine19 & 0xFFFF
    227            pNewItem->endpoint = endpoint;
    228            pNewItem->CBs = callbacks;
    229          
    230            // Find spot in list
    231            if (  zclGenCBs == NULL )
   \                     ??CrossCallReturnLabel_27:
   \   00004C   90....       MOV       DPTR,#zclGenCBs
   \   00004F   12....       LCALL     ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000052   90....       MOV       DPTR,#zclGenCBs
   \   000055   6012         JZ        ??zclGeneral_RegisterCmdCallbacks_3
    232            {
    233              zclGenCBs = pNewItem;
    234            }
    235            else
    236            {
    237              // Look for end of list
    238              pLoop = zclGenCBs;
   \   000057   E0           MOVX      A,@DPTR
   \   000058   FC           MOV       R4,A
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   8003         SJMP      ??zclGeneral_RegisterCmdCallbacks_4
    239              while ( pLoop->next != NULL )
    240                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   00005D   EA           MOV       A,R2
   \   00005E   FC           MOV       R4,A
   \   00005F   EB           MOV       A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000060   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000063   70F8         JNZ       ??zclGeneral_RegisterCmdCallbacks_5
    241          
    242              // Put new item at end of list
    243              pLoop->next = pNewItem;
   \   000065   8C82         MOV       DPL,R4
   \   000067   8D83         MOV       DPH,R5
    244            }
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000069   12....       LCALL     ?Subroutine20 & 0xFFFF
    245          
    246            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_48:
   \   00006C   7900         MOV       R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   00006E   80..         SJMP      ??Subroutine31_0
    247          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E8           MOV       A,R0
   \   000001                REQUIRE ??Subroutine33_0
   \   000001                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E9           MOV       A,R1
   \   000003   F0           MOVX      @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8882         MOV       DPL,R0
   \   000002   8983         MOV       DPH,R1
   \   000004   E4           CLR       A
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   8882         MOV       DPL,R0
   \   00000A   8983         MOV       DPH,R1
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   E5..         MOV       A,?V0
   \   000010   F0           MOVX      @DPTR,A
   \   000011   8882         MOV       DPL,R0
   \   000013   8983         MOV       DPH,R1
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   EE           MOV       A,R6
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   A3           INC       DPTR
   \   00001B   EF           MOV       A,R7
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   FD           MOV       R5,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005                REQUIRE ??Subroutine37_0
   \   000005                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   22           RET
    248          
    249          #ifdef ZCL_IDENTIFY
    250          /*********************************************************************
    251           * @fn      zclGeneral_SendIdentify
    252           *
    253           * @brief   Call to send out an Identify Command
    254           *
    255           * @param   srcEP - Sending application's endpoint
    256           * @param   dstAddr - where you want the message to go
    257           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    258           * @param   seqNum - identification number for the transaction
    259           *
    260           * @return  ZStatus_t
    261           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    262          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    263                                             uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    265            uint8 buf[2];
    266          
    267            buf[0] = LO_UINT16( identifyTime );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    268            buf[1] = HI_UINT16( identifyTime );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine21 & 0xFFFF
    269          
    270            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    271                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    272                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_29:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..00       MOV       ?V0,#0x0
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   75..01       MOV       ?V0,#0x1
   \   000053                REQUIRE ?Subroutine1
   \   000053                ; // Fall through to label ?Subroutine1
    273          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   78..         MOV       R0,#?V0
   \   000002   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV       ?V0,#0x0
   \   000008   78..         MOV       R0,#?V0
   \   00000A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00000D   7C03         MOV       R4,#0x3
   \   00000F   7D00         MOV       R5,#0x0
   \   000011   EE           MOV       A,R6
   \   000012   F9           MOV       R1,A
   \   000013   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000016   740B         MOV       A,#0xb
   \   000018   12....       LCALL     ?DEALLOC_XSTACK8
   \   00001B   7402         MOV       A,#0x2
   \   00001D                REQUIRE ??Subroutine32_0
   \   00001D                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F02         MOV       R7,#0x2
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   ED           MOV       A,R5
   \   000001   F0           MOVX      @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   A8..         MOV       R0,?XSP + 0
   \   000004   A9..         MOV       R1,?XSP + 1
   \   000006   88..         MOV       ?V0,R0
   \   000008   89..         MOV       ?V1,R1
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET
    274          
    275          /*********************************************************************
    276           * @fn      zclGeneral_SendIdentifyEZModeInvoke
    277           *
    278           * @brief   Call to send out an Identify EZ-Mode Invoke Command
    279           *
    280           * @param   srcEP - Sending application's endpoint
    281           * @param   dstAddr - where you want the message to go
    282           * @param   action - describes the EZ-Mode action to be performed
    283           * @param   seqNum - identification number for the transaction
    284           *
    285           * @return  ZStatus_t
    286           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine31_0
   \   000003                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    287          ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyEZModeInvoke:
    288                                                         uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
    289          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EC           MOV       A,R4
    290            uint8 buf[1];
    291          
    292            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   12....       LCALL     ?Subroutine22 & 0xFFFF
    293          
    294            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    295                                    COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    296                                    disableDefaultRsp, 0, seqNum, 1, buf );
   \                     ??CrossCallReturnLabel_31:
   \   000016   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000019   75..01       MOV       ?V2,#0x1
   \   00001C   75..00       MOV       ?V3,#0x0
   \   00001F   78..         MOV       R0,#?V2
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000024   7411         MOV       A,#0x11
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   E0           MOVX      A,@DPTR
   \   00002A   F5..         MOV       ?V1,A
   \   00002C   78..         MOV       R0,#?V1
   \   00002E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000031   E4           CLR       A
   \   000032   F5..         MOV       ?V2,A
   \   000034   78..         MOV       R0,#?V2
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   ED           MOV       A,R5
   \   00003A   F5..         MOV       ?V1,A
   \   00003C   78..         MOV       R0,#?V1
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000041   75..00       MOV       ?V1,#0x0
   \   000044   78..         MOV       R0,#?V1
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000049   75..01       MOV       ?V1,#0x1
   \   00004C   78..         MOV       R0,#?V1
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000051   75..02       MOV       ?V1,#0x2
   \   000054   78..         MOV       R0,#?V1
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000059   7C03         MOV       R4,#0x3
   \   00005B   7D00         MOV       R5,#0x0
   \   00005D   EE           MOV       A,R6
   \   00005E   F9           MOV       R1,A
   \   00005F   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   000062   740B         MOV       A,#0xb
   \   000064   12....       LCALL     ?DEALLOC_XSTACK8
   \   000067   7401         MOV       A,#0x1
   \   000069   02....       LJMP      ?Subroutine0 & 0xFFFF
    297          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001                ; Setup parameters for call to function zcl_SendCommand
   \   000001   A8..         MOV       R0,?XSP + 0
   \   000003   A9..         MOV       R1,?XSP + 1
   \   000005   88..         MOV       ?V2,R0
   \   000007   89..         MOV       ?V3,R1
   \   000009   78..         MOV       R0,#?V2
   \   00000B   22           RET
    298          
    299          /*********************************************************************
    300           * @fn      zclGeneral_SendIdentifyUpdateCommState
    301           *
    302           * @brief   Call to send out an Identify Update Commission State Command
    303           *
    304           * @param   srcEP - Sending application's endpoint
    305           * @param   dstAddr - where you want the message to go
    306           * @param   action - describes the EZ-Mode action to be performed
    307           * @param   commissionStateMask - updates the device's commission state
    308           * @param   seqNum - identification number for the transaction
    309           *
    310           * @return  ZStatus_t
    311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    312          ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyUpdateCommState:
    313                                                            uint8 action, uint8 commissionStateMask,
    314                                                            uint8 disableDefaultRsp, uint8 seqNum )
    315          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
   \   00000C   EC           MOV       A,R4
    316            uint8 buf[2];
    317          
    318            buf[0] = action;
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    319            buf[1] = commissionStateMask;
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   ED           MOV       A,R5
   \   00001A   12....       LCALL     ?Subroutine22 & 0xFFFF
    320          
    321            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    322                                    COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    323                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_32:
   \   00001D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000020   75..02       MOV       ?V2,#0x2
   \   000023   75..00       MOV       ?V3,#0x0
   \   000026   78..         MOV       R0,#?V2
   \   000028   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002B   7413         MOV       A,#0x13
   \   00002D   12....       LCALL     ?XSTACK_DISP0_8
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F5..         MOV       ?V1,A
   \   000033   78..         MOV       R0,#?V1
   \   000035   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000038   E4           CLR       A
   \   000039   F5..         MOV       ?V2,A
   \   00003B   78..         MOV       R0,#?V2
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   7415         MOV       A,#0x15
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F5..         MOV       ?V1,A
   \   000048   78..         MOV       R0,#?V1
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004D   75..00       MOV       ?V1,#0x0
   \   000050   78..         MOV       R0,#?V1
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000055   75..01       MOV       ?V1,#0x1
   \   000058   78..         MOV       R0,#?V1
   \   00005A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005D   75..03       MOV       ?V1,#0x3
   \   000060   78..         MOV       R0,#?V1
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000065   7C03         MOV       R4,#0x3
   \   000067   7D00         MOV       R5,#0x0
   \   000069   A9..         MOV       R1,?V0
   \   00006B   12....       LCALL     `??zcl_SendCommand::?relay`; Banked call to: zcl_SendCommand
   \   00006E   740B         MOV       A,#0xb
   \   000070   12....       LCALL     ?DEALLOC_XSTACK8
   \   000073   7402         MOV       A,#0x2
   \   000075   02....       LJMP      ?Subroutine0 & 0xFFFF
    324          }
    325          
    326          #ifdef ZCL_LIGHT_LINK_ENHANCE
    327          /*********************************************************************
    328           * @fn      zclGeneral_SendIdentifyTriggerEffect
    329           *
    330           * @brief   Call to send out a Trigger Effect Command
    331           *
    332           * @param   srcEP - Sending application's endpoint
    333           * @param   dstAddr - where you want the message to go
    334           * @param   effectId - identify effect to use
    335           * @param   effectVariant - which variant of effect to be triggered
    336           * @param   disableDefaultRsp - whether to disable the Default Response command
    337           * @param   seqNum - identification number for the transaction
    338           *
    339           * @return  ZStatus_t
    340           */
    341          ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
    342                                                          uint8 effectId, uint8 effectVariant,
    343                                                          uint8 disableDefaultRsp, uint8 seqNum )
    344          {
    345            uint8 buf[2];
    346          
    347            buf[0] = effectId;
    348            buf[1] = effectVariant;
    349          
    350            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    351                                    COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    352                                    disableDefaultRsp, 0, seqNum, 2, buf );
    353          }
    354          #endif // ZCL_LIGHT_LINK_ENHANCE
    355          
    356          /*********************************************************************
    357           * @fn      zclGeneral_SendIdentifyQueryResponse
    358           *
    359           * @brief   Call to send out an Identify Query Response Command
    360           *
    361           * @param   srcEP - Sending application's endpoint
    362           * @param   dstAddr - where you want the message to go
    363           * @param   timeout - how long the device will continue to identify itself (in seconds)
    364           * @param   seqNum - identification number for the transaction
    365           *
    366           * @return  ZStatus_t
    367           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    368          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    369                                                          uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    370          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    371            uint8 buf[2];
    372          
    373            buf[0] = LO_UINT16( timeout );
   \   00000C   EC           MOV       A,R4
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   F0           MOVX      @DPTR,A
    374            buf[1] = HI_UINT16( timeout );
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ?Subroutine21 & 0xFFFF
    375          
    376            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    377                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    378                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_30:
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..02       MOV       ?V0,#0x2
   \   000022   75..00       MOV       ?V1,#0x0
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7411         MOV       A,#0x11
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000035   E4           CLR       A
   \   000036   F5..         MOV       ?V0,A
   \   000038   78..         MOV       R0,#?V0
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7413         MOV       A,#0x13
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   75..01       MOV       ?V0,#0x1
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000050   02....       LJMP      ?Subroutine1 & 0xFFFF
    379          }
    380          #endif // ZCL_IDENTIFY
    381          
    382          #ifdef ZCL_GROUPS
    383          /*********************************************************************
    384           * @fn      zclGeneral_SendGroupRequest
    385           *
    386           * @brief   Send a Group Request to a device.  You can also use the
    387           *          appropriate macro.
    388           *
    389           * @param   srcEP - Sending Apps endpoint
    390           * @param   dstAddr - where to send the request
    391           * @param   cmd - one of the following:
    392           *              COMMAND_GROUP_VIEW
    393           *              COMMAND_GROUP_REMOVE
    394           * @param   groupID -
    395           *
    396           * @return  ZStatus_t
    397           */
    398          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    399                                                 uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    400          {
    401            uint8 buf[2];
    402          
    403            buf[0] = LO_UINT16( groupID );
    404            buf[1] = HI_UINT16( groupID );
    405          
    406            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    407                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    408                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    409          }
    410          
    411          /*********************************************************************
    412           * @fn      zclGeneral_SendAddGroupRequest
    413           *
    414           * @brief   Send the Add Group Request to a device
    415           *
    416           * @param   srcEP - Sending Apps endpoint
    417           * @param   dstAddr - where to send the request
    418           * @param   cmd - one of the following:
    419           *                COMMAND_GROUP_ADD
    420           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    421           * @param   groupID - pointer to the group structure
    422           * @param   groupName - pointer to Group Name.  This is a Zigbee
    423           *          string data type, so the first byte is the length of the
    424           *          name (in bytes), then the name.
    425           *
    426           * @return  ZStatus_t
    427           */
    428          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    429                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    430                                                    uint8 disableDefaultRsp, uint8 seqNum )
    431          {
    432            uint8 *buf;
    433            uint8 *pBuf;
    434            uint8 len;
    435            ZStatus_t status;
    436          
    437            len = 2;    // Group ID
    438            len += groupName[0] + 1;  // String + 1 for length
    439          
    440            buf = zcl_mem_alloc( len );
    441            if ( buf )
    442            {
    443              pBuf = buf;
    444              *pBuf++ = LO_UINT16( groupID );
    445              *pBuf++ = HI_UINT16( groupID );
    446              *pBuf++ = groupName[0]; // string length
    447              zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
    448          
    449              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    450                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    451                                        disableDefaultRsp, 0, seqNum, len, buf );
    452              zcl_mem_free( buf );
    453            }
    454            else
    455              status = ZMemError;
    456          
    457            return ( status );
    458          }
    459          
    460          /*********************************************************************
    461           * @fn      zclGeneral_SendGroupGetMembershipRequest
    462           *
    463           * @brief   Send a Get Group Membership (Resposne) Command to a device
    464           *
    465           * @param   srcEP - Sending Apps endpoint
    466           * @param   dstAddr - where to send the request
    467           * @param   cmd - one of the following:
    468           *                COMMAND_GROUP_GET_MEMBERSHIP
    469           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    470           * @param   groupID - pointer to the group structure
    471           * @param   groupName - pointer to Group Name.  This is a Zigbee
    472           *          string data type, so the first byte is the length of the
    473           *          name (in bytes), then the name.
    474           *
    475           * @return  ZStatus_t
    476           */
    477          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    478                                                              uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    479                                                              uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    480          {
    481            uint8 *buf;
    482            uint8 *pBuf;
    483            uint8 len = 0;
    484            uint8 i;
    485            ZStatus_t status;
    486          
    487            if ( rspCmd )
    488              len++;  // Capacity
    489          
    490            len++;  // Group Count
    491            len += sizeof ( uint16 ) * grpCnt;  // Group List
    492          
    493            buf = zcl_mem_alloc( len );
    494            if ( buf )
    495            {
    496              pBuf = buf;
    497              if ( rspCmd )
    498                *pBuf++ = capacity;
    499          
    500              *pBuf++ = grpCnt;
    501              for ( i = 0; i < grpCnt; i++ )
    502              {
    503                *pBuf++ = LO_UINT16( grpList[i] );
    504                *pBuf++ = HI_UINT16( grpList[i] );
    505              }
    506          
    507              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    508                                        cmd, TRUE, direction,
    509                                        disableDefaultRsp, 0, seqNum, len, buf );
    510              zcl_mem_free( buf );
    511            }
    512            else
    513              status = ZMemError;
    514          
    515            return ( status );
    516          }
    517          
    518          /*********************************************************************
    519           * @fn      zclGeneral_SendGroupResponse
    520           *
    521           * @brief   Send Group Response (not Group View Response)
    522           *
    523           * @param   srcEP - Sending application's endpoint
    524           * @param   dstAddr - where you want the message to go
    525           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    526           * @param   status - group command status
    527           * @param   groupID - what group
    528           *
    529           * @return  ZStatus_t
    530           */
    531          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    532                                                  uint8 cmd, uint8 status, uint16 groupID,
    533                                                  uint8 disableDefaultRsp, uint8 seqNum )
    534          {
    535            uint8 buf[3];
    536          
    537            buf[0] = status;
    538            buf[1] = LO_UINT16( groupID );
    539            buf[2] = HI_UINT16( groupID );
    540          
    541            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    542                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    543                                    disableDefaultRsp, 0, seqNum, 3, buf );
    544          }
    545          
    546          /*********************************************************************
    547           * @fn      zclGeneral_SendGroupViewResponse
    548           *
    549           * @brief   Call to send Group Response Command
    550           *
    551           * @param   srcEP - Sending application's endpoint
    552           * @param   dstAddr - where you want the message to go
    553           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    554           * @param   status - group command status
    555           * @param   grp - group info
    556           *
    557           * @return  ZStatus_t
    558           */
    559          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    560                                                      uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    561          {
    562            uint8 *buf;
    563            uint8 len;
    564            ZStatus_t stat;
    565          
    566            len = 1 + 2 + 1; // Status + Group ID + name length
    567          
    568            if ( status == ZCL_STATUS_SUCCESS )
    569            {
    570              len += grp->name[0];  // String length
    571            }
    572          
    573            buf = zcl_mem_alloc( len );
    574            if ( buf )
    575            {
    576              buf[0] = status;
    577              buf[1] = LO_UINT16( grp->ID );
    578              buf[2] = HI_UINT16( grp->ID );
    579          
    580              if ( status == ZCL_STATUS_SUCCESS )
    581              {
    582                buf[3] = grp->name[0]; // string length
    583                zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    584              }
    585              else //ZCL_STATUS_NOT_FOUND
    586              {
    587                buf[3] = 0;
    588              }
    589          
    590              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    591                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    592                                      disableDefaultRsp, 0, seqNum, len, buf );
    593              zcl_mem_free( buf );
    594            }
    595            else
    596            {
    597              stat = ZMemError;
    598            }
    599          
    600            return ( stat );
    601          }
    602          #endif // ZCL_GROUPS
    603          
    604          #ifdef ZCL_SCENES
    605          /*********************************************************************
    606           * @fn      zclGeneral_SendAddSceneRequest
    607           *
    608           * @brief   Send the (Enhanced) Add Scene Request to a device. You can
    609           *           also use the appropriate macro.
    610           *
    611           * @param   srcEP - Sending Apps endpoint
    612           * @param   dstAddr - where to send the request
    613           * @param   scene - pointer to the scene structure
    614           * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
    615           * @param   disableDefaultRsp - whether to disable the Default Response command
    616           * @param   seqNum - sequence number
    617           *
    618           * @return  ZStatus_t
    619           */
    620          ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    621                                                    uint8 cmd, zclGeneral_Scene_t *scene,
    622                                                    uint8 disableDefaultRsp, uint8 seqNum )
    623          {
    624            uint8 *buf;
    625            uint8 *pBuf;
    626            uint8 len;
    627            ZStatus_t status;
    628          
    629            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    630            len += scene->name[0] + 1; // String + 1 for length
    631          
    632            // Add something for the extension field length
    633            len += scene->extLen;
    634          
    635            buf = zcl_mem_alloc( len );
    636            if ( buf )
    637            {
    638              pBuf = buf;
    639              *pBuf++ = LO_UINT16( scene->groupID );
    640              *pBuf++ = HI_UINT16( scene->groupID );
    641              *pBuf++ = scene->ID;
    642              *pBuf++ = LO_UINT16( scene->transTime );
    643              *pBuf++ = HI_UINT16( scene->transTime );
    644              *pBuf++ = scene->name[0]; // string length
    645              zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    646              pBuf += scene->name[0]; // move pass name
    647          
    648              // Add the extension fields
    649              if ( scene->extLen > 0 )
    650                zcl_memcpy( pBuf, scene->extField, scene->extLen );
    651          
    652              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    653                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    654                                        disableDefaultRsp, 0, seqNum, len, buf );
    655              zcl_mem_free( buf );
    656            }
    657            else
    658              status = ZMemError;
    659          
    660            return ( status );
    661          }
    662          
    663          /*********************************************************************
    664           * @fn      zclGeneral_SendSceneRequest
    665           *
    666           * @brief   Send a Scene Request to a device.  You can also use the
    667           *          appropriate macro.
    668           *
    669           * @param   srcEP - Sending Apps endpoint
    670           * @param   dstAddr - where to send the request
    671           * @param   cmd - one of the following:
    672           *              COMMAND_SCENE_VIEW
    673           *              COMMAND_SCENE_REMOVE
    674           *              COMMAND_SCENE_REMOVE_ALL
    675           *              COMMAND_SCENE_STORE
    676           *              COMMAND_SCENE_RECALL
    677           *              COMMAND_SCENE_GET_MEMBERSHIP
    678           *              COMMAND_SCENE_ENHANCED_VIEW
    679           * @param   groupID - group ID
    680           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    681           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    682           * @param   disableDefaultRsp - whether to disable the Default Response command
    683           * @param   seqNum - sequence number
    684           * @return  ZStatus_t
    685           */
    686          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    687                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    688                                                 uint8 disableDefaultRsp, uint8 seqNum )
    689          {
    690            uint8 buf[3];
    691            uint8 len = 2;
    692          
    693            buf[0] = LO_UINT16( groupID );
    694            buf[1] = HI_UINT16( groupID );
    695          
    696            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    697            {
    698              buf[2] = sceneID;
    699              len++;
    700            }
    701          
    702            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    703                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    704                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    705          }
    706          
    707          /*********************************************************************
    708           * @fn      zclGeneral_SendSceneResponse
    709           *
    710           * @brief   Send Group Response (not Group View Response)
    711           *
    712           * @param   srcEP - Sending application's endpoint
    713           * @param   dstAddr - where you want the message to go
    714           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    715           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    716           * @param   status - scene command status
    717           * @param   groupID - what group
    718           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    719           *
    720           * @return  ZStatus_t
    721           */
    722          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    723                                                  uint8 cmd, uint8 status, uint16 groupID,
    724                                                  uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    725          {
    726            uint8 buf[4];
    727            uint8 len = 1 + 2; // Status + Group ID
    728          
    729            buf[0] = status;
    730            buf[1] = LO_UINT16( groupID );
    731            buf[2] = HI_UINT16( groupID );
    732          
    733            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    734            {
    735              buf[3] = sceneID;
    736              len++;
    737            }
    738          
    739            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    740                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    741                                    disableDefaultRsp, 0, seqNum, len, buf );
    742          }
    743          
    744          /*********************************************************************
    745           * @fn      zclGeneral_SendSceneViewResponse
    746           *
    747           * @brief   Call to send Scene (Enahced) View Response Command. You can
    748           *           also use the appropriate macro.
    749           *
    750           * @param   srcEP - Sending application's endpoint
    751           * @param   dstAddr - where you want the message to go
    752           * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
    753           * @param   status - scene command status
    754           * @param   scene - scene info
    755           *
    756           * @return  ZStatus_t
    757           */
    758          ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
    759                                                 uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
    760                                                 uint8 disableDefaultRsp, uint8 seqNum )
    761          {
    762            uint8 *buf;
    763            uint8 *pBuf;
    764            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    765            ZStatus_t stat;
    766          
    767            if ( status == ZCL_STATUS_SUCCESS )
    768            {
    769              len += 2; // Transition Time
    770              len += scene->name[0] + 1; // string + 1 for length
    771          
    772              // Add something for the extension field length
    773              len += scene->extLen;
    774            }
    775          
    776            buf = zcl_mem_alloc( len );
    777            if ( buf )
    778            {
    779              pBuf = buf;
    780              *pBuf++ = status;
    781              *pBuf++ = LO_UINT16( scene->groupID );
    782              *pBuf++ = HI_UINT16( scene->groupID );
    783              *pBuf++ = scene->ID;
    784              if ( status == ZCL_STATUS_SUCCESS )
    785              {
    786                uint16 transTime = scene->transTime;
    787                if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
    788                {
    789                  // Transition time is in 1/10s
    790                  transTime *= 10;
    791                  transTime += scene->transTime100ms;
    792                }
    793          
    794                *pBuf++ = LO_UINT16( transTime );
    795                *pBuf++ = HI_UINT16( transTime );
    796                *pBuf++ = scene->name[0]; // string length
    797                if ( scene->name[0] != 0 )
    798                {
    799                  zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    800                  pBuf += scene->name[0]; // move pass name
    801                }
    802          
    803                // Add the extension fields
    804                if ( scene->extLen > 0 )
    805                  zcl_memcpy( pBuf, scene->extField, scene->extLen );
    806              }
    807          
    808              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    809                                      cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    810                                      disableDefaultRsp, 0, seqNum, len, buf );
    811              zcl_mem_free( buf );
    812            }
    813            else
    814              stat = ZMemError;
    815          
    816            return ( stat );
    817          }
    818          
    819          /*********************************************************************
    820           * @fn      zclGeneral_SendSceneGetMembershipResponse
    821           *
    822           * @brief   Call to send Scene Get Membership Response Command
    823           *
    824           * @param   srcEP - Sending application's endpoint
    825           * @param   dstAddr - where you want the message to go
    826           * @param   status - scene command status
    827           * @param   capacity - remaining capacity of the scene table
    828           * @param   sceneCnt - number of scenes in the scene list
    829           * @param   sceneList - list of scene IDs
    830           * @param   groupID - group ID that scene belongs to
    831           * @param   seqNum - sequence number
    832           *
    833           * @return  ZStatus_t
    834           */
    835          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    836                                                               uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    837                                                               uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    838          {
    839            uint8 *buf;
    840            uint8 *pBuf;
    841            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    842            uint8 i;
    843            ZStatus_t stat;
    844          
    845            if ( status == ZCL_STATUS_SUCCESS )
    846            {
    847              len++; // Scene Count
    848              len += sceneCnt; // Scene List (Scene ID is a single octet)
    849            }
    850          
    851            buf = zcl_mem_alloc( len );
    852            if ( buf )
    853            {
    854              pBuf = buf;
    855              *pBuf++ = status;
    856              *pBuf++ = capacity;
    857              *pBuf++ = LO_UINT16( groupID );
    858              *pBuf++ = HI_UINT16( groupID );
    859              if ( status == ZCL_STATUS_SUCCESS )
    860              {
    861                *pBuf++ = sceneCnt;
    862                for ( i = 0; i < sceneCnt; i++ )
    863                  *pBuf++ = sceneList[i];
    864              }
    865          
    866              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    867                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    868                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    869              zcl_mem_free( buf );
    870            }
    871            else
    872              stat = ZMemError;
    873          
    874            return ( stat );
    875          }
    876          
    877          #ifdef ZCL_LIGHT_LINK_ENHANCE
    878          /*********************************************************************
    879           * @fn      zclGeneral_SendSceneCopy
    880           *
    881           * @brief   Send Scene Copy Request to a device
    882           *
    883           * @param   srcEP - sending application's endpoint
    884           * @param   dstAddr - where to send the request
    885           * @param   mode - how scene copy is to proceed
    886           * @param   groupIDFrom - group from which scene to be copied
    887           * @param   sceneIDFrom - scene from which scene to be copied
    888           * @param   groupIDTo - group to which scene to be copied
    889           * @param   sceneIDTo - scene to which scene to be copied
    890           * @param   disableDefaultRsp - disable Default Response command
    891           * @param   seqNum - the identification number for the transaction
    892           *
    893           * @return  ZStatus_t
    894           */
    895          ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
    896                                              uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
    897                                              uint16 groupIDTo, uint8 sceneIDTo,
    898                                              uint8 disableDefaultRsp, uint8 seqNum )
    899          {
    900            uint8 buf[7];
    901          
    902            buf[0] = mode;
    903            buf[1] = LO_UINT16( groupIDFrom );
    904            buf[2] = HI_UINT16( groupIDFrom );
    905            buf[3] = sceneIDFrom;
    906            buf[4] = LO_UINT16( groupIDTo );
    907            buf[5] = HI_UINT16( groupIDTo );
    908            buf[6] = sceneIDTo;
    909          
    910            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    911                                      COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    912                                      disableDefaultRsp, 0, seqNum, 7, buf ) );
    913          }
    914          
    915          /*********************************************************************
    916           * @fn      zclGeneral_SendSceneCopyResponse
    917           *
    918           * @brief   Send Scene Copy Response to a device
    919           *
    920           * @param   srcEP - sending application's endpoint
    921           * @param   dstAddr - where to send the request
    922           * @param   status - status of copy scene attemp
    923           * @param   groupIDFrom - group from which scene was copied
    924           * @param   sceneIDFrom - scene from which scene was copied
    925           * @param   disableDefaultRsp - disable Default Response command
    926           * @param   seqNum - the identification number for the transaction
    927           *
    928           * @return  ZStatus_t
    929           */
    930          ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
    931                                                      uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
    932                                                      uint8 disableDefaultRsp, uint8 seqNum )
    933          {
    934            uint8 buf[4];
    935          
    936            buf[0] = status;
    937            buf[1] = LO_UINT16( groupIDFrom );
    938            buf[2] = HI_UINT16( groupIDFrom );
    939            buf[3] = sceneIDFrom;
    940          
    941            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    942                                      COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    943                                      disableDefaultRsp, 0, seqNum, 4, buf ) );
    944          }
    945          #endif // ZCL_LIGHT_LINK_ENHANCE
    946          #endif // ZCL_SCENES
    947          
    948          #ifdef ZCL_ON_OFF
    949          #ifdef ZCL_LIGHT_LINK_ENHANCE
    950          /*********************************************************************
    951           * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
    952           *
    953           * @brief   Call to send out an Off with Effect Command.
    954           *
    955           * @param   srcEP - Sending application's endpoint
    956           * @param   dstAddr - where you want the message to go
    957           * @param   effectId - fading effect to use when switching light off
    958           * @param   effectVariant - which variant of effect to be triggered
    959           * @param   disableDefaultRsp - whether to disable the Default Response command
    960           * @param   seqNum - sequence number
    961           *
    962           * @return  ZStatus_t
    963           */
    964          ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
    965                                                           uint8 effectId, uint8 effectVariant,
    966                                                           uint8 disableDefaultRsp, uint8 seqNum )
    967          {
    968            uint8 buf[2];
    969          
    970            buf[0] = effectId;
    971            buf[1] = effectVariant;
    972          
    973            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
    974                                    COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    975                                    disableDefaultRsp, 0, seqNum, 2, buf );
    976          }
    977          
    978          /*********************************************************************
    979           * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
    980           *
    981           * @brief   Call to send out an On with Timed Off Command.
    982           *
    983           * @param   srcEP - Sending application's endpoint
    984           * @param   dstAddr - where you want the message to go
    985           * @param   onOffCtrl - how the lamp is to be operated
    986           * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
    987           * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
    988           * @param   disableDefaultRsp - whether to disable the Default Response command
    989           * @param   seqNum - sequence number
    990           *
    991           * @return  ZStatus_t
    992           */
    993          ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
    994                                                             zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
    995                                                             uint8 disableDefaultRsp, uint8 seqNum )
    996          {
    997            uint8 buf[5];
    998          
    999            buf[0] = onOffCtrl.byte;
   1000            buf[1] = LO_UINT16( onTime );
   1001            buf[2] = HI_UINT16( onTime );
   1002            buf[3] = LO_UINT16( offWaitTime );
   1003            buf[4] = HI_UINT16( offWaitTime );
   1004          
   1005            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
   1006                                    COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1007                                    disableDefaultRsp, 0, seqNum, 5, buf );
   1008          }
   1009          #endif // ZCL_LIGHT_LINK_ENHANCE
   1010          #endif // ZCL_ON_OFF
   1011          
   1012          #ifdef ZCL_LEVEL_CTRL
   1013          /*********************************************************************
   1014           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
   1015           *
   1016           * @brief   Call to send out a Level Control Request. You can also use
   1017           *          the appropriate macro.
   1018           *
   1019           * @param   srcEP - Sending application's endpoint
   1020           * @param   dstAddr - where you want the message to go
   1021           * @param   cmd - one of the following:
   1022           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
   1023           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
   1024           * @param   level - what level to move to
   1025           * @param   transitionTime - how long to take to get to the level (in seconds)
   1026           *
   1027           * @return  ZStatus_t
   1028           */
   1029          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1030                                                                   uint8 cmd, uint8 level, uint16 transTime,
   1031                                                                   uint8 disableDefaultRsp, uint8 seqNum )
   1032          {
   1033            uint8 buf[3];
   1034          
   1035            buf[0] = level;
   1036            buf[1] = LO_UINT16( transTime );
   1037            buf[2] = HI_UINT16( transTime );
   1038          
   1039            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1040                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1041                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1042          }
   1043          
   1044          /*********************************************************************
   1045           * @fn      zclGeneral_SendLevelControlMoveRequest
   1046           *
   1047           * @brief   Call to send out a Level Control Request. You can also use
   1048           *          the appropriate macro.
   1049           *
   1050           * @param   srcEP - Sending application's endpoint
   1051           * @param   dstAddr - where you want the message to go
   1052           * @param   cmd - one of the following:
   1053           *              COMMAND_LEVEL_MOVE or
   1054           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
   1055           * @param   moveMode - LEVEL_MOVE_UP or
   1056           *                     LEVEL_MOVE_DOWN
   1057           * @param   rate - number of steps to take per second
   1058           *
   1059           * @return  ZStatus_t
   1060           */
   1061          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1062                                                            uint8 cmd, uint8 moveMode, uint8 rate,
   1063                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1064          {
   1065            uint8 buf[2];
   1066          
   1067            buf[0] = moveMode;
   1068            buf[1] = rate;
   1069          
   1070            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1071                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1072                                    disableDefaultRsp, 0, seqNum, 2, buf );
   1073          }
   1074          
   1075          /*********************************************************************
   1076           * @fn      zclGeneral_SendLevelControlStepRequest
   1077           *
   1078           * @brief   Call to send out a Level Control Request. You can also use
   1079           *          the appropriate macro.
   1080           *
   1081           * @param   srcEP - Sending application's endpoint
   1082           * @param   dstAddr - where you want the message to go
   1083           * @param   cmd - one of the following:
   1084           *              COMMAND_LEVEL_STEP
   1085           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
   1086           * @param   stepMode - LEVEL_STEP_UP or
   1087           *                     LEVEL_STEP_DOWN
   1088           * @param   amount - number of levels to step
   1089           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
   1090           *
   1091           * @return  ZStatus_t
   1092           */
   1093          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
   1094                                                            uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
   1095                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1096          {
   1097            uint8 buf[4];
   1098          
   1099            buf[0] = stepMode;
   1100            buf[1] = stepSize;
   1101            buf[2] = LO_UINT16( transTime );
   1102            buf[3] = HI_UINT16( transTime );
   1103          
   1104            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1105                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1106                                    disableDefaultRsp, 0, seqNum, 4, buf );
   1107          }
   1108          
   1109          /*********************************************************************
   1110           * @fn      zclGeneral_SendLevelControlStepRequest
   1111           *
   1112           * @brief   Call to send out a Level Control Request. You can also use
   1113           *          the appropriate macro.
   1114           *
   1115           * @param   srcEP - Sending application's endpoint
   1116           * @param   dstAddr - where you want the message to go
   1117           * @param   cmd - one of the following:
   1118           *              COMMAND_LEVEL_STOP
   1119           *              COMMAND_LEVEL_STOP_WITH_ON_OFF
   1120           *
   1121           * @return  ZStatus_t
   1122           */
   1123          ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1124                                                            uint8 disableDefaultRsp, uint8 seqNum )
   1125          {
   1126            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
   1127                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1128                                    disableDefaultRsp, 0, seqNum, 0, NULL );
   1129          }
   1130          #endif // ZCL_LEVEL_CTRL
   1131          
   1132          #ifdef ZCL_ALARMS
   1133          /*********************************************************************
   1134           * @fn      zclGeneral_SendAlarm
   1135           *
   1136           * @brief   Call to send out an Alarm Request Command
   1137           *
   1138           * @param   srcEP - Sending application's endpoint
   1139           * @param   dstAddr - where you want the message to go
   1140           * @param   cmd - COMMAND_ALARMS_ALARM
   1141           * @param   alarmCode - code for the cause of the alarm
   1142           * @param   clusterID - cluster whose attribute generate the alarm
   1143           *
   1144           * @return  ZStatus_t
   1145           */
   1146          ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
   1147                                          uint8 alarmCode, uint16 clusterID,
   1148                                          uint8 disableDefaultRsp, uint8 seqNum )
   1149          {
   1150            uint8 buf[3];
   1151          
   1152            buf[0] = alarmCode;
   1153            buf[1] = LO_UINT16( clusterID );
   1154            buf[2] = HI_UINT16( clusterID );
   1155          
   1156            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1157                                    COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1158                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1159          }
   1160          
   1161          /*********************************************************************
   1162           * @fn      zclGeneral_SendAlarmReset
   1163           *
   1164           * @brief   Call to send out an Alarm Reset Command
   1165           *
   1166           * @param   srcEP - Sending application's endpoint
   1167           * @param   dstAddr - where you want the message to go
   1168           * @param   alarmCode - code for the cause of the alarm
   1169           * @param   clusterID - cluster whose attribute generate the alarm
   1170           *
   1171           * @return  ZStatus_t
   1172          */
   1173          ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
   1174                                               uint8 alarmCode, uint16 clusterID,
   1175                                               uint8 disableDefaultRsp, uint8 seqNum )
   1176          {
   1177            uint8 buf[3];
   1178          
   1179            buf[0] = alarmCode;
   1180            buf[1] = LO_UINT16( clusterID );
   1181            buf[2] = HI_UINT16( clusterID );
   1182          
   1183            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1184                                    COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1185                                    disableDefaultRsp, 0, seqNum, 3, buf );
   1186          }
   1187          
   1188          /*********************************************************************
   1189           * @fn      zclGeneral_SendAlarmGetResponse
   1190           *
   1191           * @brief   Call to send out an Alarm Get Response Command
   1192           *
   1193           * @param   srcEP - Sending application's endpoint
   1194           * @param   dstAddr - where you want the message to go
   1195           * @param   status - SUCCESS or NOT_FOUND
   1196           * @param   alarmCode - code for the cause of the alarm
   1197           * @param   clusterID - cluster whose attribute generate the alarm
   1198           * @param   timeStamp - time at which the alarm occured
   1199           *
   1200           * @return  ZStatus_t
   1201           */
   1202          ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1203                                                     uint8 status, uint8 alarmCode, uint16 clusterID,
   1204                                                     uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
   1205          {
   1206            uint8 buf[8];
   1207            uint8 len = 1; // Status
   1208          
   1209            buf[0] = status;
   1210            if ( status == ZCL_STATUS_SUCCESS )
   1211            {
   1212              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
   1213              buf[1] = alarmCode;
   1214              buf[2] = LO_UINT16( clusterID );
   1215              buf[3] = HI_UINT16( clusterID );
   1216              zcl_buffer_uint32( &buf[4], timeStamp );
   1217            }
   1218          
   1219            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1220                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1221                                    disableDefaultRsp, 0, seqNum, len, buf );
   1222          }
   1223          
   1224          #ifdef SE_UK_EXT
   1225          /*********************************************************************
   1226           * @fn      zclGeneral_SendAlarmGetEventLog
   1227           *
   1228           * @brief   Call to send out an Alarm Get Event Log Command
   1229           *
   1230           * @param   srcEP - Sending application's endpoint
   1231           * @param   dstAddr - where you want the message to go
   1232           * @param   pEventLog - pointer to Get Event Log Command
   1233           * @param   disableDefaultRsp - disable default response
   1234           * @param   seqNum - ZCL sequence number
   1235           *
   1236           * @return  ZStatus_t
   1237           */
   1238          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1239                                                     zclGetEventLog_t *pEventLog,
   1240                                                     uint8 disableDefaultRsp, uint8 seqNum )
   1241          {
   1242            uint8 buf[10];
   1243          
   1244            buf[0] = pEventLog->logID;
   1245            zcl_buffer_uint32( &buf[1], pEventLog->startTime );
   1246            zcl_buffer_uint32( &buf[5], pEventLog->endTime );
   1247            buf[9] = pEventLog->numEvents;
   1248          
   1249            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1250                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1251                                    disableDefaultRsp, 0, seqNum, 10, buf );
   1252          }
   1253          
   1254          /*********************************************************************
   1255           * @fn      zclGeneral_SendAlarmPublishEventLog
   1256           *
   1257           * @brief   Call to send out an Alarm Publish Event Log Command
   1258           *
   1259           * @param   srcEP - Sending application's endpoint
   1260           * @param   dstAddr - where you want the message to go
   1261           * @param   pEventLog - pointer to Publish Event Log Command
   1262           * @param   disableDefaultRsp - disable default response
   1263           * @param   seqNum - ZCL sequence number
   1264           *
   1265           * @return  ZStatus_t
   1266           */
   1267          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
   1268                                                         zclPublishEventLog_t *pEventLog,
   1269                                                         uint8 disableDefaultRsp, uint8 seqNum )
   1270          {
   1271            uint8 *buf;
   1272            uint8 *pBuf;
   1273            uint8 bufLen;
   1274          
   1275            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
   1276            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
   1277          
   1278            buf = zcl_mem_alloc( bufLen );
   1279            if ( buf == NULL )
   1280            {
   1281              return (ZMemError);
   1282            }
   1283          
   1284            pBuf = buf;
   1285            *pBuf++ = pEventLog->logID;
   1286            *pBuf++ = pEventLog->cmdIndex;
   1287            *pBuf++ = pEventLog->totalCmds;
   1288          
   1289            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
   1290            {
   1291              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
   1292          
   1293              *pBuf++ = pLogs->eventId;
   1294              pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
   1295            }
   1296          
   1297            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1298                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1299                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1300          }
   1301          #endif // SE_UK_EXT
   1302          #endif // ZCL_ALARMS
   1303          
   1304          #ifdef ZCL_LOCATION
   1305          /*********************************************************************
   1306           * @fn      zclGeneral_SendLocationSetAbsolute
   1307           *
   1308           * @brief   Call to send out a Set Absolute Location Command
   1309           *
   1310           * @param   srcEP - Sending application's endpoint
   1311           * @param   dstAddr - where you want the message to go
   1312           * @param   absLoc - absolute location info
   1313           *
   1314           * @return  ZStatus_t
   1315           */
   1316          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1317                                                        zclLocationAbsolute_t *absLoc,
   1318                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1319          {
   1320             uint8 buf[10]; // 5 fields (2 octects each)
   1321          
   1322             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1323             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1324             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1325             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1326             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1327             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1328             buf[6] = LO_UINT16( absLoc->power );
   1329             buf[7] = HI_UINT16( absLoc->power );
   1330             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1331             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1332          
   1333             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1334                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1335                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1336          }
   1337          
   1338          /*********************************************************************
   1339           * @fn      zclGeneral_SendLocationSetDevCfg
   1340           *
   1341           * @brief   Call to send out a Set Device Configuration Command
   1342           *
   1343           * @param   srcEP - Sending application's endpoint
   1344           * @param   dstAddr - where you want the message to go
   1345           * @param   devCfg - device configuration info
   1346           *
   1347           * @return  ZStatus_t
   1348           */
   1349          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1350                                                      zclLocationDevCfg_t *devCfg,
   1351                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1352          {
   1353             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1354          
   1355             buf[0] = LO_UINT16( devCfg->power );
   1356             buf[1] = HI_UINT16( devCfg->power );
   1357             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1358             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1359             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1360             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1361             buf[6] = devCfg->numMeasurements;
   1362             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1363             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1364          
   1365             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1366                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1367                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1368          }
   1369          
   1370          /*********************************************************************
   1371           * @fn      zclGeneral_SendLocationGetDevCfg
   1372           *
   1373           * @brief   Call to send out a Get Device Configuration Command
   1374           *
   1375           * @param   srcEP - Sending application's endpoint
   1376           * @param   dstAddr - where you want the message to go
   1377           * @param   targetAddr - device for which location parameters are being requested
   1378           *
   1379           * @return  ZStatus_t
   1380           */
   1381          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1382                                                      uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1383          {
   1384            uint8 buf[8];
   1385          
   1386            zcl_memcpy( buf, targetAddr, 8 );
   1387          
   1388            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1389                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1390                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1391          }
   1392          
   1393          /*********************************************************************
   1394           * @fn      zclGeneral_SendLocationGetData
   1395           *
   1396           * @brief   Call to send out a Get Location Data Command
   1397           *
   1398           * @param   srcEP - Sending application's endpoint
   1399           * @param   dstAddr - where you want the message to go
   1400           * @param   locaData - location information and channel parameters that are requested.
   1401           *
   1402           * @return  ZStatus_t
   1403           */
   1404          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1405                                                    zclLocationGetData_t *locData,
   1406                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1407          {
   1408            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1409            uint8 *pBuf = buf;
   1410            uint8 len = 2; // bitmap + number responses
   1411          
   1412            *pBuf  = locData->absoluteOnly;
   1413            *pBuf |= locData->recalculate << 1;
   1414            *pBuf |= locData->brdcastIndicator << 2;
   1415            *pBuf |= locData->brdcastResponse << 3;
   1416            *pBuf |= locData->compactResponse << 4;
   1417            pBuf++;  // move past the bitmap field
   1418          
   1419            *pBuf++ = locData->numResponses;
   1420          
   1421            if ( locData->brdcastIndicator == 0 )
   1422            {
   1423              zcl_memcpy( pBuf, locData->targetAddr, 8 );
   1424              len += 8; // ieee addr
   1425            }
   1426          
   1427            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1428                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1429                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1430          }
   1431          
   1432          /*********************************************************************
   1433           * @fn      zclGeneral_SendLocationDevCfgResponse
   1434           *
   1435           * @brief   Call to send out a Device Configuration Response Command
   1436           *
   1437           * @param   srcEP - Sending application's endpoint
   1438           * @param   dstAddr - where you want the message to go
   1439           * @param   devCfg - device's location parameters that are requested
   1440           *
   1441           * @return  ZStatus_t
   1442           */
   1443          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1444                                                           zclLocationDevCfgRsp_t *devCfg,
   1445                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1446          {
   1447            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1448            uint8 len = 1; // Status
   1449          
   1450            buf[0] = devCfg->status;
   1451            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1452            {
   1453              buf[1] = LO_UINT16( devCfg->data.power );
   1454              buf[2] = HI_UINT16( devCfg->data.power );
   1455              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1456              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1457              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1458              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1459              buf[7] = devCfg->data.numMeasurements;
   1460              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1461              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1462              len += 9;
   1463            }
   1464          
   1465            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1466                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1467                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1468          }
   1469          
   1470          /*********************************************************************
   1471           * @fn      zclGeneral_SendLocationData
   1472           *
   1473           * @brief   Call to send out location data
   1474           *
   1475           * @param   srcEP - Sending application's endpoint
   1476           * @param   dstAddr - where you want the message to go
   1477           * @param   status - indicates whether response to request was successful or not
   1478           * @param   locData - location information and channel parameters being sent
   1479           *
   1480           * @return  ZStatus_t
   1481           */
   1482          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1483                                                 uint8 status, zclLocationData_t *locData,
   1484                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1485          {
   1486            uint8 buf[16];
   1487            uint8 *pBuf = buf;
   1488            uint8 len = 0;
   1489          
   1490            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1491            {
   1492              // Only response command includes a status field
   1493              *pBuf++ = status;
   1494              len++;
   1495            }
   1496          
   1497            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1498            {
   1499              // Notification or Response with successful status
   1500              *pBuf++ = locData->type;
   1501              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1502              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1503              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1504              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1505              len += 5;
   1506          
   1507              if ( locationType2D(locData->type) == 0 )
   1508              {
   1509                // 2D location doesn't have coordinate 3
   1510                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1511                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1512                len += 2;
   1513              }
   1514          
   1515              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1516              {
   1517                // Compact notification doesn't include these fields
   1518                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1519                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1520                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1521                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1522                len += 4;
   1523              }
   1524          
   1525              if ( locationTypeAbsolute(locData->type) == 0 )
   1526              {
   1527                // Absolute location doesn't include these fields
   1528                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1529                {
   1530                  // Compact notification doesn't include this field
   1531                  *pBuf++ = locData->calcLoc.locationMethod;
   1532                  len++;
   1533                }
   1534          
   1535                *pBuf++ = locData->calcLoc.qualityMeasure;
   1536                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1537                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1538                len += 3;
   1539              }
   1540            }
   1541          
   1542            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1543                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1544                                    disableDefaultRsp, 0, seqNum, len, buf );
   1545          }
   1546          #endif // ZCL_LOCATION
   1547          
   1548          /*********************************************************************
   1549           * @fn      zclGeneral_FindCallbacks
   1550           *
   1551           * @brief   Find the callbacks for an endpoint
   1552           *
   1553           * @param   endpoint - endpoint to find the application callbacks for
   1554           *
   1555           * @return  pointer to the callbacks
   1556           */
   1557          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1558          {
   1559            zclGenCBRec_t *pCBs;
   1560          
   1561            pCBs = zclGenCBs;
   1562            while ( pCBs )
   1563            {
   1564              if ( pCBs->endpoint == endpoint )
   1565                return ( pCBs->CBs );
   1566              pCBs = pCBs->next;
   1567            }
   1568            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1569          }
   1570          
   1571          /*********************************************************************
   1572           * @fn      zclGeneral_HdlIncoming
   1573           *
   1574           * @brief   Callback from ZCL to process incoming Commands specific
   1575           *          to this cluster library or Profile commands for attributes
   1576           *          that aren't in the attribute list
   1577           *
   1578           *
   1579           * @param   pInMsg - pointer to the incoming message
   1580           *
   1581           * @return  ZStatus_t
   1582           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1583          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1584          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1585            ZStatus_t stat = ZSuccess;
   1586          
   1587          #if defined ( INTER_PAN )
   1588            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1589              return ( stat ); // Cluster not supported thru Inter-PAN
   1590          #endif
   1591            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   5407         ANL       A,#0x7
   \   00000D   6401         XRL       A,#0x1
   \   00000F   7007         JNZ       ??zclGeneral_HdlIncoming_0
   1592            {
   1593              // Is this a manufacturer specific command?
   1594              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1595              {
   1596                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000011                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000011   12....       LCALL     `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
   \   000014   E9           MOV       A,R1
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclGeneral_HdlIncoming_1
   1597              }
   1598              else
   1599              {
   1600                // We don't support any manufacturer specific command.
   1601                stat = ZFailure;
   1602              }
   1603            }
   1604            else
   1605            {
   1606              // Handle all the normal (Read, Write...) commands -- should never get here
   1607              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   000018   7901         MOV       R1,#0x1
   1608            }
   1609            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001A                REQUIRE ?Subroutine2
   \   00001A                ; // Fall through to label ?Subroutine2
   1610          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
   1611          
   1612          /*********************************************************************
   1613           * @fn      zclGeneral_HdlInSpecificCommands
   1614           *
   1615           * @brief   Callback from ZCL to process incoming Commands specific
   1616           *          to this cluster library
   1617          
   1618           * @param   pInMsg - pointer to the incoming message
   1619           *
   1620           * @return  ZStatus_t
   1621           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1622          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1623          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1624            ZStatus_t stat;
   1625            zclGeneral_AppCallbacks_t *pCBs;
   1626          
   1627            // make sure endpoint exists
   1628            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   8B83         MOV       DPH,R3
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FE           MOV       R6,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000015   F8           MOV       R0,A
   \   000016   90....       MOV       DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000019   12....       LCALL     ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00001C   6056         JZ        ??zclGeneral_HdlInSpecificCommands_1
   \   00001E   8C82         MOV       DPL,R4
   \   000020   8D83         MOV       DPH,R5
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   68           XRL       A,R0
   \   000026   8C82         MOV       DPL,R4
   \   000028   8D83         MOV       DPH,R5
   \   00002A   70ED         JNZ       ??zclGeneral_HdlInSpecificCommands_0
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   12....       LCALL     ??Subroutine38_0 & 0xFFFF
   1629            if ( pCBs == NULL )
   \                     ??CrossCallReturnLabel_77:
   \   000032   6040         JZ        ??zclGeneral_HdlInSpecificCommands_1
   1630              return ( ZFailure );
   1631          
   1632            switch ( pInMsg->msg->clusterId )
   \   000034   8E82         MOV       DPL,R6
   \   000036   8F83         MOV       DPH,R7
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V0,A
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F5..         MOV       ?V1,A
   \   000043   78..         MOV       R0,#?V0
   \   000045   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000048   0000         DW        0
   \   00004A   06           DB        6
   \   00004B   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   00004D   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00004F   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   000051   ....         DW        ??zclGeneral_HdlInSpecificCommands_1
   \   000053   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000055   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   \   000057   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   \   000059   ....         DW        ??zclGeneral_HdlInSpecificCommands_6
   1633            {
   1634          #ifdef ZCL_BASIC
   1635              case ZCL_CLUSTER_ID_GEN_BASIC:
   1636                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   00005B   8A82         MOV       DPL,R2
   \   00005D   8B83         MOV       DPH,R3
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   5408         ANL       A,#0x8
   \   000064   701F         JNZ       ??zclGeneral_HdlInSpecificCommands_7
   \   000066   8A82         MOV       DPL,R2
   \   000068   8B83         MOV       DPH,R3
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   6005         JZ        ??zclGeneral_HdlInSpecificCommands_8
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   000074   7901         MOV       R1,#0x1
   \   000076   02....       LJMP      ??zclGeneral_HdlInSpecificCommands_9 & 0xFFFF
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   000079   8C82         MOV       DPL,R4
   \   00007B   8D83         MOV       DPH,R5
   \   00007D   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000080   6003         JZ        ??zclGeneral_HdlInSpecificCommands_7
   \   000082                ; Setup parameters for indirect call
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   000082   12....       LCALL     ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000085   7900         MOV       R1,#0x0
   \   000087   02....       LJMP      ??zclGeneral_HdlInSpecificCommands_9 & 0xFFFF
   1637                break;
   1638          #endif // ZCL_BASIC
   1639          
   1640              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1641                //stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   1642                // JC NOTE: Add support for handling ZCL Identify Query Response
   1643                stat = zclGeneral_ProcessInIdentityJC(pInMsg, pCBs);
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   00008A   8A82         MOV       DPL,R2
   \   00008C   8B83         MOV       DPH,R3
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   E0           MOVX      A,@DPTR
   \   000091   5408         ANL       A,#0x8
   \   000093   60F0         JZ        ??zclGeneral_HdlInSpecificCommands_7
   \   000095   8A82         MOV       DPL,R2
   \   000097   8B83         MOV       DPH,R3
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   A3           INC       DPTR
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   70D1         JNZ       ??zclGeneral_HdlInSpecificCommands_1
   \   0000A3   EE           MOV       A,R6
   \   0000A4   2406         ADD       A,#0x6
   \   0000A6   F8           MOV       R0,A
   \   0000A7   E4           CLR       A
   \   0000A8   3F           ADDC      A,R7
   \   0000A9   F9           MOV       R1,A
   \   0000AA   85..82       MOV       DPL,?XSP + 0
   \   0000AD   85..83       MOV       DPH,?XSP + 1
   \   0000B0   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0000B3   8A82         MOV       DPL,R2
   \   0000B5   8B83         MOV       DPH,R3
   \   0000B7   A3           INC       DPTR
   \   0000B8   A3           INC       DPTR
   \   0000B9   A3           INC       DPTR
   \   0000BA   A3           INC       DPTR
   \   0000BB   A3           INC       DPTR
   \   0000BC   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000BF   8882         MOV       DPL,R0
   \   0000C1   8983         MOV       DPH,R1
   \   0000C3   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0000C6   7402         MOV       A,#0x2
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0000CE   EC           MOV       A,R4
   \   0000CF   2414         ADD       A,#0x14
   \   0000D1   F582         MOV       DPL,A
   \   0000D3   E4           CLR       A
   \   0000D4   3D           ADDC      A,R5
   \   0000D5   F583         MOV       DPH,A
   \   0000D7   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000DA   60A9         JZ        ??zclGeneral_HdlInSpecificCommands_7
   \   0000DC                ; Setup parameters for indirect call
   \   0000DC   AA..         MOV       R2,?XSP + 0
   \   0000DE   AB..         MOV       R3,?XSP + 1
   \   0000E0   80A0         SJMP      ??zclGeneral_HdlInSpecificCommands_10
   1644                break;
   1645          
   1646              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1647                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   0000E2   8A82         MOV       DPL,R2
   \   0000E4   8B83         MOV       DPH,R3
   \   0000E6   A3           INC       DPTR
   \   0000E7   A3           INC       DPTR
   \   0000E8   E0           MOVX      A,@DPTR
   \   0000E9   5408         ANL       A,#0x8
   \   0000EB   6050         JZ        ??zclGeneral_HdlInSpecificCommands_9
   1648                {
   1649          #ifdef ZCL_GROUPS
   1650                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1651          #endif
   1652                }
   1653                else
   1654                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   \   0000ED                ; Setup parameters for call to function zclGeneral_ProcessInGroupsClient
   \   0000ED   12....       LCALL     `??zclGeneral_ProcessInGroupsClient::?relay`; Banked call to: zclGeneral_ProcessInGroupsClient
   \   0000F0   800E         SJMP      ??zclGeneral_HdlInSpecificCommands_11
   1655                break;
   1656          
   1657              case ZCL_CLUSTER_ID_GEN_SCENES:
   1658                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   0000F2   8A82         MOV       DPL,R2
   \   0000F4   8B83         MOV       DPH,R3
   \   0000F6   A3           INC       DPTR
   \   0000F7   A3           INC       DPTR
   \   0000F8   E0           MOVX      A,@DPTR
   \   0000F9   5408         ANL       A,#0x8
   \   0000FB   6040         JZ        ??zclGeneral_HdlInSpecificCommands_9
   1659                {
   1660          #ifdef ZCL_SCENES
   1661                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1662          #endif // ZCL_SCENES
   1663                }
   1664                else
   1665                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   \   0000FD                ; Setup parameters for call to function zclGeneral_ProcessInScenesClient
   \   0000FD   12....       LCALL     `??zclGeneral_ProcessInScenesClient::?relay`; Banked call to: zclGeneral_ProcessInScenesClient
   \                     ??zclGeneral_HdlInSpecificCommands_11:
   \   000100   E9           MOV       A,R1
   \   000101   8039         SJMP      ??zclGeneral_HdlInSpecificCommands_12
   1666                break;
   1667          
   1668          #ifdef ZCL_ON_OFF
   1669              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1670                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   000103   7E00         MOV       R6,#0x0
   \   000105   8A82         MOV       DPL,R2
   \   000107   8B83         MOV       DPH,R3
   \   000109   A3           INC       DPTR
   \   00010A   A3           INC       DPTR
   \   00010B   E0           MOVX      A,@DPTR
   \   00010C   5408         ANL       A,#0x8
   \   00010E   702B         JNZ       ??zclGeneral_HdlInSpecificCommands_13
   \   000110   8A82         MOV       DPL,R2
   \   000112   8B83         MOV       DPH,R3
   \   000114   A3           INC       DPTR
   \   000115   A3           INC       DPTR
   \   000116   A3           INC       DPTR
   \   000117   A3           INC       DPTR
   \   000118   A3           INC       DPTR
   \   000119   A3           INC       DPTR
   \   00011A   A3           INC       DPTR
   \   00011B   E0           MOVX      A,@DPTR
   \   00011C   FA           MOV       R2,A
   \   00011D   6006         JZ        ??zclGeneral_HdlInSpecificCommands_14
   \   00011F   14           DEC       A
   \   000120   6003         JZ        ??zclGeneral_HdlInSpecificCommands_14
   \   000122   14           DEC       A
   \   000123   7014         JNZ       ??zclGeneral_HdlInSpecificCommands_15
   \                     ??zclGeneral_HdlInSpecificCommands_14:
   \   000125   8C82         MOV       DPL,R4
   \   000127   8D83         MOV       DPH,R5
   \   000129   A3           INC       DPTR
   \   00012A   A3           INC       DPTR
   \   00012B   A3           INC       DPTR
   \   00012C   A3           INC       DPTR
   \   00012D   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000130   6009         JZ        ??zclGeneral_HdlInSpecificCommands_13
   \   000132                ; Setup parameters for indirect call
   \   000132   EA           MOV       A,R2
   \   000133   F9           MOV       R1,A
   \   000134   12....       LCALL     ?CALL_IND
   \   000137   8002         SJMP      ??zclGeneral_HdlInSpecificCommands_13
   \                     ??zclGeneral_HdlInSpecificCommands_15:
   \   000139   7E01         MOV       R6,#0x1
   \                     ??zclGeneral_HdlInSpecificCommands_13:
   \   00013B   EE           MOV       A,R6
   \                     ??zclGeneral_HdlInSpecificCommands_12:
   \   00013C   F9           MOV       R1,A
   1671                break;
   1672          #endif // ZCL_ON_OFF
   1673          
   1674          #ifdef ZCL_LEVEL_CTRL
   1675              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1676                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1677                break;
   1678          #endif // ZCL_LEVEL_CTRL
   1679          
   1680          #ifdef ZCL_ALARMS
   1681              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1682                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1683                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1684                else
   1685                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1686                break;
   1687          #endif // ZCL_ALARMS
   1688          
   1689          #ifdef ZCL_LOCATION
   1690              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1691                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1692                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1693                else
   1694                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1695                break;
   1696          #endif // ZCL_LOCATION
   1697          
   1698              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1699              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1700              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1701              case ZCL_CLUSTER_ID_GEN_TIME:
   1702              default:
   1703                stat = ZFailure;
   1704                break;
   1705            }
   1706          
   1707            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   00013D   7404         MOV       A,#0x4
   \   00013F   02....       LJMP      ??Subroutine32_0 & 0xFFFF
   1708          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine34_0
   \   000003                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   12....       LCALL     ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000003   F9           MOV       R1,A
   \   000004   8882         MOV       DPL,R0
   \   000006   8983         MOV       DPH,R1
   \   000008   E582         MOV       A,DPL
   \   00000A   4583         ORL       A,DPH
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   EA           MOV       A,R2
   \   000006   F8           MOV       R0,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   FF           MOV       R7,A
   \   000001   EE           MOV       A,R6
   \   000002   2414         ADD       A,#0x14
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   3F           ADDC      A,R7
   \   000008   F583         MOV       DPH,A
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EC           MOV       A,R4
   \   000006   4D           ORL       A,R5
   \   000007   22           RET
   1709          
   1710          #ifdef ZCL_BASIC
   1711          /*********************************************************************
   1712           * @fn      zclGeneral_ProcessInBasic
   1713           *
   1714           * @brief   Process in the received Basic Command.
   1715           *
   1716           * @param   pInMsg - pointer to the incoming message
   1717           *
   1718           * @return  ZStatus_t
   1719           */
   1720          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1721                                                      zclGeneral_AppCallbacks_t *pCBs )
   1722          {
   1723            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1724            {
   1725              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1726                return ( ZFailure );   // Error ignore the command
   1727          
   1728              if ( pCBs->pfnBasicReset )
   1729                pCBs->pfnBasicReset();
   1730            }
   1731            // no Client command
   1732          
   1733            return ( ZSuccess );
   1734          }
   1735          #endif // ZCL_BASIC
   1736          
   1737          /*********************************************************************
   1738           * @fn      zclGeneral_ProcessInIdentityJC
   1739           *
   1740           * @brief   Process in the received Identity Query Response Command.
   1741           *
   1742           * @param   pInMsg - pointer to the incoming message
   1743           *
   1744           * @return  ZStatus_t
   1745           */
   1746          static ZStatus_t zclGeneral_ProcessInIdentityJC( zclIncoming_t *pInMsg,
   1747                                                         zclGeneral_AppCallbacks_t *pCBs )
   1748          {
   1749            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1750            {
   1751              // We do not care about the ZCL Identify command sent to the coordinator
   1752            }
   1753            else // Client Command
   1754            {
   1755              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   1756                return ( ZFailure );   // Error ignore the command
   1757          
   1758              zclIdentifyQueryRsp_t rsp;
   1759              
   1760              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1761              rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1762          
   1763              if (pCBs->pfnIdentifyQueryRsp)
   1764              {
   1765                pCBs->pfnIdentifyQueryRsp(&rsp);
   1766              }
   1767              
   1768              //bdb_ZclIdentifyQueryCmdInd( &rsp );
   1769            }
   1770            return ( ZSuccess );
   1771          }
   1772          
   1773          #ifdef ZCL_IDENTIFY
   1774          /*********************************************************************
   1775           * @fn      zclGeneral_ProcessInIdentity
   1776           *
   1777           * @brief   Process in the received Identity Command.
   1778           *
   1779           * @param   pInMsg - pointer to the incoming message
   1780           *
   1781           * @return  ZStatus_t
   1782           */
   1783          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
                                  ^
Warning[Pe177]: function "zclGeneral_ProcessInIdentity" was declared but never
          referenced
   1784                                                         zclGeneral_AppCallbacks_t *pCBs )
   1785          {
   1786            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1787            {
   1788              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   1789              {
   1790                uint16 identifyTime;
   1791                
   1792                identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1793                
   1794                bdb_ZclIdentifyCmdInd( identifyTime, pInMsg->msg->endPoint);
   1795              }
   1796              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
   1797              {
   1798                uint16 identifyTime = 0;
   1799          
   1800                // Retrieve Identify Time
   1801                zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   1802                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   1803          
   1804                // Is device identifying itself?
   1805                if ( identifyTime > 0 )
   1806                {
   1807                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1808                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   1809                  return ( ZCL_STATUS_CMD_HAS_RSP );
   1810                }
   1811              }
   1812          
   1813          #ifdef ZCL_LIGHT_LINK_ENHANCE
   1814              else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
   1815              {
   1816                if ( pCBs->pfnIdentifyTriggerEffect )
   1817                {
   1818                  zclIdentifyTriggerEffect_t cmd;
   1819          
   1820                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1821                  cmd.effectId = pInMsg->pData[0];
   1822                  cmd.effectVariant = pInMsg->pData[1];
   1823          
   1824                  pCBs->pfnIdentifyTriggerEffect( &cmd );
   1825                }
   1826              }
   1827          #endif //ZCL_LIGHT_LINK_ENHANCE
   1828              else
   1829              {
   1830                return ( ZFailure );   // Error ignore the command
   1831              }
   1832            }
   1833            else // Client Command
   1834            {
   1835              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   1836                return ( ZFailure );   // Error ignore the command
   1837          
   1838              zclIdentifyQueryRsp_t rsp;
   1839              
   1840              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1841              rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1842              
   1843              bdb_ZclIdentifyQueryCmdInd( &rsp );
   1844            }
   1845            return ( ZSuccess );
   1846          }
   1847          #endif // ZCL_IDENTIFY
   1848          
   1849          #ifdef ZCL_GROUPS
   1850          
   1851          /*********************************************************************
   1852           * @fn      zclGeneral_AddGroup
   1853           *
   1854           * @brief   Add a Group.
   1855           *
   1856           * @param   endPoint - application endpoint
   1857           * @param   group - group to be added
   1858           * @param   pData - pointer to the group info
   1859           *
   1860           * @return  ZStatus_t
   1861           */
   1862          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1863          {
   1864            uint8 nameLen;
   1865            uint8 nameSupport = FALSE;
   1866          
   1867            pData += 2;   // Move past group ID
   1868            nameLen = *pData++;
   1869          
   1870            // Retrieve Name Support attribute
   1871            zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
   1872                              ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
   1873          
   1874            if ( nameSupport )
   1875            {
   1876              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1877                 nameLen = (APS_GROUP_NAME_LEN-1);
   1878              group->name[0] = nameLen;
   1879              zcl_memcpy( &(group->name[1]), pData, nameLen );
   1880            }
   1881          
   1882            return ( aps_AddGroup( endPoint, group ) );
   1883          }
   1884          
   1885          /*********************************************************************
   1886           * @fn      zclGeneral_ProcessInGroupsServer
   1887           *
   1888           * @brief   Process in the received Groups Command.
   1889           *
   1890           * @param   pInMsg - pointer to the incoming message
   1891           *
   1892           * @return  ZStatus_t
   1893           */
   1894          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1895          {
   1896            aps_Group_t group;
   1897            aps_Group_t *pGroup;
   1898            uint8 *pData;
   1899            uint8 status;
   1900            uint8 grpCnt;
   1901            uint8 grpRspCnt = 0;
   1902            uint16 *grpList;
   1903            uint16 identifyTime = 0;
   1904            uint8 i;
   1905            ZStatus_t stat = ZSuccess;
   1906          
   1907            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1908          
   1909            pData = pInMsg->pData;
   1910            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1911            switch ( pInMsg->hdr.commandID )
   1912            {
   1913              case COMMAND_GROUP_ADD:
   1914                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1915                if ( status != ZSuccess )
   1916                {
   1917                  if ( status == ZApsDuplicateEntry )
   1918                  {
   1919                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1920                  }
   1921                  else
   1922                  {
   1923                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1924                  }
   1925                }
   1926          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1927                if ( UNICAST_MSG( pInMsg->msg ) )
   1928          #endif
   1929                {
   1930                  zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1931                                                   status, group.ID, true, pInMsg->hdr.transSeqNum );
   1932                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1933                }
   1934                break;
   1935          
   1936              case COMMAND_GROUP_VIEW:
   1937          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1938                if ( UNICAST_MSG( pInMsg->msg ) )
   1939          #endif
   1940                {
   1941                  pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1942                  if ( pGroup )
   1943                  {
   1944                    status = ZCL_STATUS_SUCCESS;
   1945                  }
   1946                  else
   1947                  {
   1948                    // Group not found
   1949                    status = ZCL_STATUS_NOT_FOUND;
   1950                    pGroup = &group;
   1951                  }
   1952                  zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1953                                                    status, pGroup, true, pInMsg->hdr.transSeqNum );
   1954                  stat = ZCL_STATUS_CMD_HAS_RSP;
   1955                }
   1956                break;
   1957          
   1958              case COMMAND_GROUP_GET_MEMBERSHIP:
   1959          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   1960                if ( UNICAST_MSG( pInMsg->msg ) )
   1961          #endif
   1962                {
   1963                  grpCnt = *pData++;
   1964          
   1965                  // Allocate space for the group list
   1966                  grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1967                  if ( grpList != NULL )
   1968                  {
   1969                    if ( grpCnt == 0 )
   1970                    {
   1971                      // Find out all the groups of which the endpoint is a member.
   1972                      grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1973                    }
   1974                    else
   1975                    {
   1976                      // Find out the groups (in the list) of which the endpoint is a member.
   1977                      for ( i = 0; i < grpCnt; i++ )
   1978                      {
   1979                        group.ID = BUILD_UINT16( pData[0], pData[1] );
   1980                        pData += 2;
   1981          
   1982                        if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1983                          grpList[grpRspCnt++] = group.ID;
   1984                      }
   1985                    }
   1986          
   1987                    if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1988                    {
   1989                      zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1990                                                                 aps_GroupsRemaingCapacity(), grpRspCnt,
   1991                                                                 grpList, true, pInMsg->hdr.transSeqNum );
   1992                    }
   1993          
   1994                    zcl_mem_free( grpList );
   1995                  }
   1996                  else
   1997                  {
   1998                    // Couldn't allocate space for the group list -- send a Default Response command back.
   1999                    zclDefaultRspCmd_t defaultRspCmd;
   2000          
   2001                    defaultRspCmd.commandID = pInMsg->hdr.commandID;
   2002                    defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   2003                    zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   2004                                           pInMsg->msg->clusterId, &defaultRspCmd,
   2005                                           ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   2006                  }
   2007          
   2008                  stat = ZCL_STATUS_CMD_HAS_RSP;
   2009                }
   2010                break;
   2011          
   2012              case COMMAND_GROUP_REMOVE:
   2013          #if defined ( ZCL_SCENES )
   2014                zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
   2015          #endif
   2016                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   2017                {
   2018                  status = ZCL_STATUS_SUCCESS;
   2019                }
   2020                else
   2021                {
   2022                  status = ZCL_STATUS_NOT_FOUND;
   2023                }
   2024          
   2025          #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
   2026                if ( UNICAST_MSG( pInMsg->msg ) )
   2027          #endif
   2028                {
   2029                  zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2030                                                      status, group.ID, true, pInMsg->hdr.transSeqNum );
   2031                  stat = ZCL_STATUS_CMD_HAS_RSP;
   2032                }
   2033                break;
   2034          
   2035              case COMMAND_GROUP_REMOVE_ALL:
   2036                {
   2037                  uint8 numGroups;
   2038                  uint16 groupList[APS_MAX_GROUPS];
   2039          
   2040                  if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
   2041                  {
   2042                    for ( i = 0; i < numGroups; i++ )
   2043                    {
   2044          #if defined ( ZCL_SCENES )
   2045                      zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
   2046          #endif
   2047                    }
   2048          
   2049                    aps_RemoveAllGroup( pInMsg->msg->endPoint );
   2050                  }
   2051                }
   2052                break;
   2053          
   2054              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   2055                // Retrieve Identify Time
   2056                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2057                                  ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
   2058          
   2059                // Is device identifying itself?
   2060                if ( identifyTime > 0 )
   2061                {
   2062                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   2063                }
   2064                break;
   2065          
   2066              default:
   2067                stat = ZFailure;
   2068                break;
   2069            }
   2070          
   2071            return ( stat );
   2072          }
   2073          #endif // ZCL_GROUPS
   2074          /*********************************************************************
   2075           * @fn      zclGeneral_ProcessInGroupsClient
   2076           *
   2077           * @brief   Process in the received Groups Command.
   2078           *
   2079           * @param   pInMsg - pointer to the incoming message
   2080           *
   2081           * @return  ZStatus_t
   2082           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2083          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInGroupsClient:
   2084                                                             zclGeneral_AppCallbacks_t *pCBs )
   2085          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   7402         MOV       A,#0x2
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   EC           MOV       A,R4
   \   00001B   F0           MOVX      @DPTR,A
   \   00001C   A3           INC       DPTR
   \   00001D   ED           MOV       A,R5
   \   00001E   F0           MOVX      @DPTR,A
   2086            aps_Group_t group;
   2087            uint8 *pData = pInMsg->pData;
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine11 & 0xFFFF
   2088            uint8 grpCnt;
   2089            uint8 nameLen;
   2090            zclGroupRsp_t rsp;
   2091            uint8 i;
   2092            ZStatus_t stat = ZSuccess;
   \                     ??CrossCallReturnLabel_15:
   \   000027   75..00       MOV       ?V3,#0x0
   2093          
   2094            zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   \   00002A                ; Setup parameters for call to function osal_memset
   \   00002A   7C12         MOV       R4,#0x12
   \   00002C   7D00         MOV       R5,#0x0
   \   00002E   7900         MOV       R1,#0x0
   \   000030   740E         MOV       A,#0xe
   \   000032   12....       LCALL     ?XSTACK_DISP101_8
   \   000035   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2095            zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   \   000038                ; Setup parameters for call to function osal_memset
   \   000038   7C0A         MOV       R4,#0xa
   \   00003A   7D00         MOV       R5,#0x0
   \   00003C   7900         MOV       R1,#0x0
   \   00003E   7404         MOV       A,#0x4
   \   000040   12....       LCALL     ?XSTACK_DISP101_8
   \   000043   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2096          
   2097            switch ( pInMsg->hdr.commandID )
   \   000046   EE           MOV       A,R6
   \   000047   2402         ADD       A,#0x2
   \   000049   FA           MOV       R2,A
   \   00004A   E4           CLR       A
   \   00004B   3F           ADDC      A,R7
   \   00004C   FB           MOV       R3,A
   \   00004D   8E82         MOV       DPL,R6
   \   00004F   8F83         MOV       DPH,R7
   \   000051   A3           INC       DPTR
   \   000052   A882         MOV       R0,DPL
   \   000054   A983         MOV       R1,DPH
   \   000056   7402         MOV       A,#0x2
   \   000058   12....       LCALL     ?XSTACK_DISP0_8
   \   00005B   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00005E   600F         JZ        ??zclGeneral_ProcessInGroupsClient_0
   \   000060   14           DEC       A
   \   000061   600C         JZ        ??zclGeneral_ProcessInGroupsClient_0
   \   000063   14           DEC       A
   \   000064   7003         JNZ       $+5
   \   000066   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_1 & 0xFFFF
   \   000069   14           DEC       A
   \   00006A   6003         JZ        $+5
   \   00006C   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_2 & 0xFFFF
   2098            {
   2099              case COMMAND_GROUP_ADD_RSP:
   2100              case COMMAND_GROUP_VIEW_RSP:
   2101              case COMMAND_GROUP_REMOVE_RSP:
   2102                rsp.status = *pData++;
   \                     ??zclGeneral_ProcessInGroupsClient_0:
   \   00006F   8E82         MOV       DPL,R6
   \   000071   8F83         MOV       DPH,R7
   \   000073   E0           MOVX      A,@DPTR
   \   000074   FC           MOV       R4,A
   \   000075   7407         MOV       A,#0x7
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   EC           MOV       A,R4
   \   00007B   F0           MOVX      @DPTR,A
   \   00007C   E8           MOV       A,R0
   \   00007D   FE           MOV       R6,A
   \   00007E   E9           MOV       A,R1
   \   00007F   FF           MOV       R7,A
   2103                group.ID = BUILD_UINT16( pData[0], pData[1] );
   \   000080   8E82         MOV       DPL,R6
   \   000082   8F83         MOV       DPH,R7
   \   000084   E0           MOVX      A,@DPTR
   \   000085   F5..         MOV       ?V0,A
   \   000087   8A82         MOV       DPL,R2
   \   000089   8B83         MOV       DPH,R3
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   F9           MOV       R1,A
   \   00008D   740E         MOV       A,#0xe
   \   00008F   12....       LCALL     ?XSTACK_DISP0_8
   \   000092   E5..         MOV       A,?V0
   \   000094   12....       LCALL     ??Subroutine33_0 & 0xFFFF
   2104          
   2105                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   \                     ??CrossCallReturnLabel_47:
   \   000097   EC           MOV       A,R4
   \   000098   7054         JNZ       ??CrossCallReturnLabel_51
   \   00009A   85..82       MOV       DPL,?V6
   \   00009D   85..83       MOV       DPH,?V7
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   6401         XRL       A,#0x1
   \   0000A3   7049         JNZ       ??CrossCallReturnLabel_51
   2106                {
   2107                  pData += 2;   // Move past ID
   2108                  nameLen = *pData++;
   \   0000A5   8E82         MOV       DPL,R6
   \   0000A7   8F83         MOV       DPH,R7
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F9           MOV       R1,A
   \   0000AD   EE           MOV       A,R6
   \   0000AE   2403         ADD       A,#0x3
   \   0000B0   FE           MOV       R6,A
   \   0000B1   5001         JNC       ??zclGeneral_ProcessInGroupsClient_3
   \   0000B3   0F           INC       R7
   2109                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   \                     ??zclGeneral_ProcessInGroupsClient_3:
   \   0000B4   E9           MOV       A,R1
   \   0000B5   C3           CLR       C
   \   0000B6   9410         SUBB      A,#0x10
   \   0000B8   4002         JC        ??zclGeneral_ProcessInGroupsClient_4
   2110                    nameLen = (APS_GROUP_NAME_LEN-1);
   \   0000BA   790F         MOV       R1,#0xf
   2111                  group.name[0] = nameLen;
   \                     ??zclGeneral_ProcessInGroupsClient_4:
   \   0000BC   7410         MOV       A,#0x10
   \   0000BE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C1   E9           MOV       A,R1
   \   0000C2   12....       LCALL     ?Subroutine23 & 0xFFFF
   2112                  zcl_memcpy( &(group.name[1]), pData, nameLen );
   \                     ??CrossCallReturnLabel_33:
   \   0000C5   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000C8   E9           MOV       A,R1
   \   0000C9   FC           MOV       R4,A
   \   0000CA   7D00         MOV       R5,#0x0
   \   0000CC   7414         MOV       A,#0x14
   \   0000CE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D1   AA82         MOV       R2,DPL
   \   0000D3   AB83         MOV       R3,DPH
   \   0000D5   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000D8   7403         MOV       A,#0x3
   \   0000DA   12....       LCALL     ?DEALLOC_XSTACK8
   2113                  rsp.grpName = group.name;
   \   0000DD   7410         MOV       A,#0x10
   \   0000DF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E2   A882         MOV       R0,DPL
   \   0000E4   A983         MOV       R1,DPH
   \   0000E6   740C         MOV       A,#0xc
   \   0000E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EB   12....       LCALL     ?Subroutine20 & 0xFFFF
   2114                }
   2115          
   2116                if ( pCBs->pfnGroupRsp )
   \                     ??CrossCallReturnLabel_51:
   \   0000EE   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000F1   7003         JNZ       $+5
   \   0000F3   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_5 & 0xFFFF
   2117                {
   2118                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0000F6   7402         MOV       A,#0x2
   \   0000F8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FB   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   0000FE   12....       LCALL     ?XSTACK_DISP0_8
   \   000101   12....       LCALL     ?Subroutine18 & 0xFFFF
   2119                  rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_23:
   \   000104   C0E0         PUSH      A
   \   000106   7406         MOV       A,#0x6
   \   000108   12....       LCALL     ?XSTACK_DISP0_8
   \   00010B   D0E0         POP       A
   \   00010D   F0           MOVX      @DPTR,A
   2120                  rsp.grpCnt = 1;
   \   00010E   7408         MOV       A,#0x8
   \   000110   12....       LCALL     ?XSTACK_DISP0_8
   \   000113   7401         MOV       A,#0x1
   \   000115   F0           MOVX      @DPTR,A
   2121                  rsp.grpList = &group.ID;
   \   000116   740E         MOV       A,#0xe
   \   000118   12....       LCALL     ?XSTACK_DISP100_8
   \   00011B   7409         MOV       A,#0x9
   \   00011D   12....       LCALL     ?XSTACK_DISP0_8
   \   000120   12....       LCALL     ?Subroutine20 & 0xFFFF
   2122                  rsp.capacity = 0;
   \                     ??CrossCallReturnLabel_52:
   \   000123   740B         MOV       A,#0xb
   \   000125   12....       LCALL     ?XSTACK_DISP0_8
   \   000128   E4           CLR       A
   \   000129   F0           MOVX      @DPTR,A
   2123          
   2124                  pCBs->pfnGroupRsp( &rsp );
   \   00012A                ; Setup parameters for indirect call
   \   00012A   7404         MOV       A,#0x4
   \   00012C   12....       LCALL     ?XSTACK_DISP101_8
   \   00012F   12....       LCALL     ?Subroutine5 & 0xFFFF
   2125                }
   \                     ??CrossCallReturnLabel_3:
   \   000132   12....       LCALL     ?CALL_IND
   \   000135   02....       LJMP      ??zclGeneral_ProcessInGroupsClient_5 & 0xFFFF
   2126                break;
   2127          
   2128              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   2129                {
   2130                  uint16 *grpList = NULL;
   \                     ??zclGeneral_ProcessInGroupsClient_1:
   \   000138   75..00       MOV       ?V0,#0x0
   \   00013B   75..00       MOV       ?V1,#0x0
   2131                  rsp.capacity = *pData++;
   \   00013E   8E82         MOV       DPL,R6
   \   000140   8F83         MOV       DPH,R7
   \   000142   E0           MOVX      A,@DPTR
   \   000143   C0E0         PUSH      A
   \   000145   740B         MOV       A,#0xb
   \   000147   12....       LCALL     ?XSTACK_DISP0_8
   \   00014A   D0E0         POP       A
   \   00014C   F0           MOVX      @DPTR,A
   2132                  grpCnt = *pData++;
   \   00014D   8882         MOV       DPL,R0
   \   00014F   8983         MOV       DPH,R1
   \   000151   E0           MOVX      A,@DPTR
   \   000152   F5..         MOV       ?V2,A
   \   000154   0E           INC       R6
   \   000155   0E           INC       R6
   \   000156   EB           MOV       A,R3
   \   000157   FF           MOV       R7,A
   2133          
   2134                  if ( grpCnt > 0 )
   \   000158   E5..         MOV       A,?V2
   \   00015A   6052         JZ        ??zclGeneral_ProcessInGroupsClient_6
   2135                  {
   2136                    // Allocate space for the group list
   2137                    grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
   \   00015C                ; Setup parameters for call to function osal_mem_alloc
   \   00015C   25E0         ADD       A,0xE0 /* A   */
   \   00015E   FA           MOV       R2,A
   \   00015F   E4           CLR       A
   \   000160   33           RLC       A
   \   000161   FB           MOV       R3,A
   \   000162   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000165   8A..         MOV       ?V0,R2
   \   000167   8B..         MOV       ?V1,R3
   2138                    if ( grpList != NULL )
   \   000169   EA           MOV       A,R2
   \   00016A   45..         ORL       A,?V1
   \   00016C   6040         JZ        ??zclGeneral_ProcessInGroupsClient_6
   2139                    {
   2140                      rsp.grpCnt = grpCnt;
   \   00016E   7408         MOV       A,#0x8
   \   000170   12....       LCALL     ?XSTACK_DISP0_8
   \   000173   E5..         MOV       A,?V2
   \   000175   F0           MOVX      @DPTR,A
   2141                      for ( i = 0; i < grpCnt; i++ )
   \   000176   7A00         MOV       R2,#0x0
   \   000178   802E         SJMP      ??zclGeneral_ProcessInGroupsClient_7
   2142                      {
   2143                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInGroupsClient_8:
   \   00017A   8E82         MOV       DPL,R6
   \   00017C   8F83         MOV       DPH,R7
   \   00017E   E0           MOVX      A,@DPTR
   \   00017F   FC           MOV       R4,A
   \   000180   A3           INC       DPTR
   \   000181   E0           MOVX      A,@DPTR
   \   000182   F8           MOV       R0,A
   \   000183   E4           CLR       A
   \   000184   C8           XCH       A,R0
   \   000185   F9           MOV       R1,A
   \   000186   EC           MOV       A,R4
   \   000187   28           ADD       A,R0
   \   000188   E4           CLR       A
   \   000189   39           ADDC      A,R1
   \   00018A   FD           MOV       R5,A
   \   00018B   EA           MOV       A,R2
   \   00018C   25E0         ADD       A,0xE0 /* A   */
   \   00018E   F8           MOV       R0,A
   \   00018F   E4           CLR       A
   \   000190   33           RLC       A
   \   000191   F9           MOV       R1,A
   \   000192   E5..         MOV       A,?V0
   \   000194   28           ADD       A,R0
   \   000195   F582         MOV       DPL,A
   \   000197   EB           MOV       A,R3
   \   000198   39           ADDC      A,R1
   \   000199   F583         MOV       DPH,A
   \   00019B   EC           MOV       A,R4
   \   00019C   F0           MOVX      @DPTR,A
   \   00019D   A3           INC       DPTR
   \   00019E   ED           MOV       A,R5
   \   00019F   F0           MOVX      @DPTR,A
   2144                        pData += 2;
   \   0001A0   EE           MOV       A,R6
   \   0001A1   2402         ADD       A,#0x2
   \   0001A3   FE           MOV       R6,A
   \   0001A4   5001         JNC       ??zclGeneral_ProcessInGroupsClient_9
   \   0001A6   0F           INC       R7
   2145                      }
   \                     ??zclGeneral_ProcessInGroupsClient_9:
   \   0001A7   0A           INC       R2
   \                     ??zclGeneral_ProcessInGroupsClient_7:
   \   0001A8   EA           MOV       A,R2
   \   0001A9   C3           CLR       C
   \   0001AA   95..         SUBB      A,?V2
   \   0001AC   40CC         JC        ??zclGeneral_ProcessInGroupsClient_8
   2146                    }
   2147                  }
   2148          
   2149                  if ( pCBs->pfnGroupRsp )
   \                     ??zclGeneral_ProcessInGroupsClient_6:
   \   0001AE   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0001B1   602F         JZ        ??zclGeneral_ProcessInGroupsClient_10
   2150                  {
   2151                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0001B3   7402         MOV       A,#0x2
   \   0001B5   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B8   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0001BB   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BE   12....       LCALL     ?Subroutine18 & 0xFFFF
   2152                    rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_24:
   \   0001C1   C0E0         PUSH      A
   \   0001C3   7406         MOV       A,#0x6
   \   0001C5   12....       LCALL     ?XSTACK_DISP0_8
   \   0001C8   D0E0         POP       A
   \   0001CA   F0           MOVX      @DPTR,A
   2153                    rsp.grpList = grpList;
   \   0001CB   7409         MOV       A,#0x9
   \   0001CD   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D0   E5..         MOV       A,?V0
   \   0001D2   F0           MOVX      @DPTR,A
   \   0001D3   A3           INC       DPTR
   \   0001D4   E5..         MOV       A,?V1
   \   0001D6   F0           MOVX      @DPTR,A
   2154          
   2155                    pCBs->pfnGroupRsp( &rsp );
   \   0001D7                ; Setup parameters for indirect call
   \   0001D7   7404         MOV       A,#0x4
   \   0001D9   12....       LCALL     ?XSTACK_DISP101_8
   \   0001DC   12....       LCALL     ?Subroutine5 & 0xFFFF
   2156                  }
   \                     ??CrossCallReturnLabel_4:
   \   0001DF   12....       LCALL     ?CALL_IND
   2157          
   2158                  if ( grpList != NULL )
   \                     ??zclGeneral_ProcessInGroupsClient_10:
   \   0001E2   E5..         MOV       A,?V0
   \   0001E4   45..         ORL       A,?V1
   \   0001E6   600C         JZ        ??zclGeneral_ProcessInGroupsClient_5
   2159                  {
   2160                    zcl_mem_free( grpList );
   \   0001E8                ; Setup parameters for call to function osal_mem_free
   \   0001E8   AA..         MOV       R2,?V0
   \   0001EA   AB..         MOV       R3,?V1
   \   0001EC   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0001EF   8003         SJMP      ??zclGeneral_ProcessInGroupsClient_5
   2161                  }
   2162                }
   2163                break;
   2164          
   2165              default:
   2166                stat = ZFailure;
   \                     ??zclGeneral_ProcessInGroupsClient_2:
   \   0001F1   75..01       MOV       ?V3,#0x1
   2167                break;
   2168            }
   2169          
   2170            return ( stat );
   \                     ??zclGeneral_ProcessInGroupsClient_5:
   \   0001F4   A9..         MOV       R1,?V3
   \   0001F6   7420         MOV       A,#0x20
   \   0001F8                REQUIRE ?Subroutine3
   \   0001F8                ; // Fall through to label ?Subroutine3
   2171          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F08         MOV       R7,#0x8
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   49           ORL       A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   F583         MOV       DPH,A
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   12....       LCALL     ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000009   C8           XCH       A,R0
   \   00000A   240C         ADD       A,#0xc
   \   00000C   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001   8E..         MOV       ?V0,R6
   \   000003   8F..         MOV       ?V1,R7
   \   000005   75..00       MOV       ?V2,#0x0
   \   000008   78..         MOV       R0,#?V0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   85..82       MOV       DPL,?V6
   \   000008   85..83       MOV       DPH,?V7
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2407         ADD       A,#0x7
   \   000003   F5..         MOV       ?V6,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   3400         ADDC      A,#0x0
   \   000009   F5..         MOV       ?V7,A
   \   00000B   85..82       MOV       DPL,?V6
   \   00000E   F583         MOV       DPH,A
   \   000010   E0           MOVX      A,@DPTR
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL     ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000003   C8           XCH       A,R0
   \   000004   2408         ADD       A,#0x8
   \   000006   F582         MOV       DPL,A
   \   000008   E4           CLR       A
   \   000009   38           ADDC      A,R0
   \   00000A   F583         MOV       DPH,A
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   FE           MOV       R6,A
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   FF           MOV       R7,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   2406         ADD       A,#0x6
   \   000005   F8           MOV       R0,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   3400         ADDC      A,#0x0
   \   00000A   F9           MOV       R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   38           ADDC      A,R0
   \   000004   F583         MOV       DPH,A
   \   000006                REQUIRE ??Subroutine36_0
   \   000006                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET
   2172          
   2173          #if defined( ZCL_SCENES )
   2174          #if !defined ( ZCL_STANDALONE )
   2175          /*********************************************************************
   2176           * @fn      zclGeneral_AddScene
   2177           *
   2178           * @brief   Add a scene for an endpoint
   2179           *
   2180           * @param   endpoint -
   2181           * @param   scene - new scene item
   2182           *
   2183           * @return  ZStatus_t
   2184           */
   2185          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   2186          {
   2187            zclGenSceneItem_t *pNewItem;
   2188            zclGenSceneItem_t *pLoop;
   2189          
   2190            // Fill in the new profile list
   2191            pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
   2192            if ( pNewItem == NULL )
   2193              return ( ZMemError );
   2194          
   2195            // Fill in the plugin record.
   2196            pNewItem->next = (zclGenSceneItem_t *)NULL;
   2197            pNewItem->endpoint = endpoint;
   2198            zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   2199          
   2200            // Find spot in list
   2201            if (  zclGenSceneTable == NULL )
   2202            {
   2203              zclGenSceneTable = pNewItem;
   2204            }
   2205            else
   2206            {
   2207              // Look for end of list
   2208              pLoop = zclGenSceneTable;
   2209              while ( pLoop->next != NULL )
   2210                pLoop = pLoop->next;
   2211          
   2212              // Put new item at end of list
   2213              pLoop->next = pNewItem;
   2214            }
   2215          
   2216            // Update NV
   2217            zclGeneral_ScenesWriteNV();
   2218          
   2219            return ( ZSuccess );
   2220          }
   2221          #endif // ZCL_STANDALONE
   2222          
   2223          #if !defined ( ZCL_STANDALONE )
   2224          /*********************************************************************
   2225           * @fn      zclGeneral_FindScene
   2226           *
   2227           * @brief   Find a scene with endpoint and sceneID
   2228           *
   2229           * @param   endpoint -
   2230           * @param   groupID - what group the scene belongs to
   2231           * @param   sceneID - ID to look for scene
   2232           *
   2233           * @return  a pointer to the scene information, NULL if not found
   2234           */
   2235          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2236          {
   2237            zclGenSceneItem_t *pLoop;
   2238          
   2239            // Look for end of list
   2240            pLoop = zclGenSceneTable;
   2241            while ( pLoop )
   2242            {
   2243              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   2244                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2245              {
   2246                return ( &(pLoop->scene) );
   2247              }
   2248              pLoop = pLoop->next;
   2249            }
   2250          
   2251            return ( (zclGeneral_Scene_t *)NULL );
   2252          }
   2253          #endif // ZCL_STANDALONE
   2254          
   2255          #if !defined ( ZCL_STANDALONE )
   2256          /*********************************************************************
   2257           * @fn      zclGeneral_FindAllScenesForGroup
   2258           *
   2259           * @brief   Find all the scenes with groupID
   2260           *
   2261           * @param   endpoint - endpoint to look for
   2262           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   2263           *
   2264           * @return  number of scenes copied to sceneList
   2265           */
   2266          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   2267          {
   2268            zclGenSceneItem_t *pLoop;
   2269            uint8 cnt = 0;
   2270          
   2271            // Look for end of list
   2272            pLoop = zclGenSceneTable;
   2273            while ( pLoop )
   2274            {
   2275              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2276                sceneList[cnt++] = pLoop->scene.ID;
   2277              pLoop = pLoop->next;
   2278            }
   2279            return ( cnt );
   2280          }
   2281          #endif // ZCL_STANDALONE
   2282          
   2283          #if !defined ( ZCL_STANDALONE )
   2284          /*********************************************************************
   2285           * @fn      zclGeneral_RemoveScene
   2286           *
   2287           * @brief   Remove a scene with endpoint and sceneID
   2288           *
   2289           * @param   endpoint -
   2290           * @param   groupID - what group the scene belongs to
   2291           * @param   sceneID - ID to look for scene
   2292           *
   2293           * @return  TRUE if removed, FALSE if not found
   2294           */
   2295          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   2296          {
   2297            zclGenSceneItem_t *pLoop;
   2298            zclGenSceneItem_t *pPrev;
   2299          
   2300            // Look for end of list
   2301            pLoop = zclGenSceneTable;
   2302            pPrev = NULL;
   2303            while ( pLoop )
   2304            {
   2305              if ( pLoop->endpoint == endpoint
   2306                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   2307              {
   2308                if ( pPrev == NULL )
   2309                  zclGenSceneTable = pLoop->next;
   2310                else
   2311                  pPrev->next = pLoop->next;
   2312          
   2313                // Free the memory
   2314                zcl_mem_free( pLoop );
   2315          
   2316                // Update NV
   2317                zclGeneral_ScenesWriteNV();
   2318          
   2319                return ( TRUE );
   2320              }
   2321              pPrev = pLoop;
   2322              pLoop = pLoop->next;
   2323            }
   2324          
   2325            return ( FALSE );
   2326          }
   2327          #endif // ZCL_STANDALONE
   2328          
   2329          #if !defined ( ZCL_STANDALONE )
   2330          /*********************************************************************
   2331           * @fn      zclGeneral_RemoveAllScenes
   2332           *
   2333           * @brief   Remove all scenes with endpoint and group Id
   2334           *
   2335           * @param   endpoint -
   2336           * @param   groupID - ID to look for group
   2337           *
   2338           * @return  none
   2339           */
   2340          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   2341          {
   2342            zclGenSceneItem_t *pLoop;
   2343            zclGenSceneItem_t *pPrev;
   2344            zclGenSceneItem_t *pNext;
   2345          
   2346            // Look for end of list
   2347            pLoop = zclGenSceneTable;
   2348            pPrev = NULL;
   2349            while ( pLoop )
   2350            {
   2351              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   2352              {
   2353                if ( pPrev == NULL )
   2354                  zclGenSceneTable = pLoop->next;
   2355                else
   2356                  pPrev->next = pLoop->next;
   2357                pNext = pLoop->next;
   2358          
   2359                // Free the memory
   2360                zcl_mem_free( pLoop );
   2361                pLoop = pNext;
   2362              }
   2363              else
   2364              {
   2365                pPrev = pLoop;
   2366                pLoop = pLoop->next;
   2367              }
   2368            }
   2369          
   2370            // Update NV
   2371            zclGeneral_ScenesWriteNV();
   2372          }
   2373          #endif // ZCL_STANDALONE
   2374          
   2375          #if !defined ( ZCL_STANDALONE )
   2376          /*********************************************************************
   2377           * @fn      zclGeneral_CountScenes
   2378           *
   2379           * @brief   Count the number of scenes for an endpoint
   2380           *
   2381           * @param   endpoint -
   2382           *
   2383           * @return  number of scenes assigned to an endpoint
   2384           */
   2385          uint8 zclGeneral_CountScenes( uint8 endpoint )
   2386          {
   2387            zclGenSceneItem_t *pLoop;
   2388            uint8 cnt = 0;
   2389          
   2390            // Look for end of list
   2391            pLoop = zclGenSceneTable;
   2392            while ( pLoop )
   2393            {
   2394              if ( pLoop->endpoint == endpoint  )
   2395                cnt++;
   2396              pLoop = pLoop->next;
   2397            }
   2398            return ( cnt );
   2399          }
   2400          #endif
   2401          
   2402          #if !defined ( ZCL_STANDALONE )
   2403          /*********************************************************************
   2404           * @fn      zclGeneral_CountAllScenes
   2405           *
   2406           * @brief   Count the total number of scenes
   2407           *
   2408           * @param   none
   2409           *
   2410           * @return  number of scenes
   2411           */
   2412          uint8 zclGeneral_CountAllScenes( void )
   2413          {
   2414            zclGenSceneItem_t *pLoop;
   2415            uint8 cnt = 0;
   2416          
   2417            // Look for end of list
   2418            pLoop = zclGenSceneTable;
   2419            while ( pLoop )
   2420            {
   2421              cnt++;
   2422              pLoop = pLoop->next;
   2423            }
   2424            return ( cnt );
   2425          }
   2426          #endif // ZCL_STANDALONE
   2427          
   2428          /*********************************************************************
   2429           * @fn      zclGeneral_ReadSceneCountCB
   2430           *
   2431           * @brief   Read the number of scenes currently in the device's
   2432           *          scene table (i.e., the Scene Count attribute).
   2433           *
   2434           *          Note: This function gets called only when the pointer
   2435           *                'dataPtr' to the Scene Count attribute value is
   2436           *                NULL in the attribute database registered with
   2437           *                the ZCL.
   2438           *
   2439           * @param   clusterId - cluster that attribute belongs to
   2440           * @param   attrId - attribute to be read or written
   2441           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
   2442           * @param   pValue - pointer to attribute value
   2443           * @param   pLen - pointer to length of attribute value read
   2444           *
   2445           * @return  status
   2446           */
   2447          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2448                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2449          {
   2450            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2451          
   2452            // This callback function should only be called for the Scene Count attribute
   2453            switch ( oper )
   2454            {
   2455              case ZCL_OPER_LEN:
   2456                *pLen = 1; // uint8
   2457                break;
   2458          
   2459              case ZCL_OPER_READ:
   2460                *pValue = zclGeneral_CountAllScenes();
   2461          
   2462                if ( pLen != NULL )
   2463                {
   2464                  *pLen = 1;
   2465                }
   2466                break;
   2467          
   2468              case ZCL_OPER_WRITE:
   2469                // Fall through
   2470          
   2471              default:
   2472                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2473                break;
   2474            }
   2475          
   2476            return ( status );
   2477          }
   2478          
   2479          /*********************************************************************
   2480           * @fn      zclGeneral_ProcessInScenesServer
   2481           *
   2482           * @brief   Process in the received Scenes Command.
   2483           *
   2484           * @param   pInMsg - pointer to the incoming message
   2485           *
   2486           * @return  ZStatus_t
   2487           */
   2488          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2489                                                             zclGeneral_AppCallbacks_t *pCBs )
   2490          {
   2491            zclGeneral_Scene_t scene;
   2492            zclGeneral_Scene_t *pScene;
   2493            uint8 *pData = pInMsg->pData;
   2494            uint8 nameLen;
   2495            uint8 status;
   2496            uint8 sceneCnt = 0;
   2497            uint8 *sceneList = NULL;
   2498            uint8 sendRsp = TRUE;
   2499            uint8 nameSupport = FALSE;
   2500            ZStatus_t stat = ZSuccess;
   2501          
   2502            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2503          
   2504            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2505            pData += 2;   // Move past group ID
   2506            scene.ID = *pData++;
   2507          
   2508            switch ( pInMsg->hdr.commandID )
   2509            {
   2510              case COMMAND_SCENE_ADD:
   2511          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2512              case COMMAND_SCENE_ENHANCED_ADD:
   2513          #endif // ZCL_LIGHT_LINK_ENHANCE
   2514                // Parse the rest of the incoming message
   2515                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2516                pData += 2;
   2517          
   2518                if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
   2519                {
   2520                  // Received transition time is in 1/10 second
   2521                  scene.transTime100ms = scene.transTime % 10;
   2522                  scene.transTime /= 10;
   2523                }
   2524          
   2525                nameLen= *pData++; // Name length
   2526          
   2527                // Retrieve Name Support attribute
   2528                zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
   2529                                  ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
   2530          
   2531                if ( nameSupport )
   2532                {
   2533                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2534                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2535                  scene.name[0] = nameLen;
   2536                  zcl_memcpy( &(scene.name[1]), pData, nameLen );
   2537                }
   2538          
   2539                pData += nameLen; // move past name, use original length
   2540          
   2541                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2542                if ( scene.extLen > 0 )
   2543                {
   2544                  // Copy the extention field(s)
   2545                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2546                  {
   2547                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2548                  }
   2549                  zcl_memcpy( scene.extField, pData, scene.extLen );
   2550                }
   2551          
   2552                if ( scene.groupID == 0x0000 ||
   2553                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2554                {
   2555                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2556                  // does and the corresponding Group exits
   2557                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2558                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2559                  {
   2560                    status = ZCL_STATUS_SUCCESS;
   2561                    if ( pScene != NULL )
   2562                    {
   2563                      // The Scene already exists so update it
   2564                      pScene->transTime = scene.transTime;
   2565                      zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2566          
   2567                      // Use the new extention field(s)
   2568                      zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
   2569                      pScene->extLen = scene.extLen;
   2570          
   2571                      // Save Scenes
   2572                      zclGeneral_ScenesSave();
   2573                    }
   2574                    else
   2575                    {
   2576                      // The Scene doesn't exist so add it
   2577                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2578                    }
   2579                  }
   2580                  else
   2581                  {
   2582                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2583                  }
   2584                }
   2585                else
   2586                {
   2587                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2588                }
   2589          
   2590                if ( UNICAST_MSG( pInMsg->msg ) )
   2591                {
   2592                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
   2593                  {
   2594                    zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2595                                                    status, scene.groupID, scene.ID,
   2596                                                    true, pInMsg->hdr.transSeqNum );
   2597                  }
   2598          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2599                  else // COMMAND_SCENE_ENHANCED_ADD
   2600                  {
   2601                    zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2602                                                            status, scene.groupID, scene.ID,
   2603                                                            true, pInMsg->hdr.transSeqNum );
   2604                  }
   2605          #endif // ZCL_LIGHT_LINK_ENHANCE
   2606                }
   2607                stat = ZCL_STATUS_CMD_HAS_RSP;
   2608          
   2609                break;
   2610          
   2611              case COMMAND_SCENE_VIEW:
   2612          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2613              case COMMAND_SCENE_ENHANCED_VIEW:
   2614          #endif // ZCL_LIGHT_LINK_ENHANCE
   2615                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2616                if ( pScene != NULL )
   2617                {
   2618                  status = ZCL_STATUS_SUCCESS;
   2619                }
   2620                else
   2621                {
   2622                  // Scene not found
   2623                  if ( scene.groupID != 0x0000 &&
   2624                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2625                  {
   2626                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2627                  }
   2628                  else
   2629                  {
   2630                    status = ZCL_STATUS_NOT_FOUND;
   2631                  }
   2632                  pScene = &scene;
   2633                }
   2634          
   2635                if ( UNICAST_MSG( pInMsg->msg ) )
   2636                {
   2637                  if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
   2638                  {
   2639                    zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2640                                                     status, pScene, true, pInMsg->hdr.transSeqNum );
   2641                  }
   2642          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2643                  else
   2644                  {
   2645                    zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2646                                                             status, pScene, true, pInMsg->hdr.transSeqNum );
   2647                  }
   2648          #endif // ZCL_LIGHT_LINK_ENHANCE
   2649                }
   2650                stat = ZCL_STATUS_CMD_HAS_RSP;
   2651                break;
   2652          
   2653              case COMMAND_SCENE_REMOVE:
   2654                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2655                {
   2656                  status = ZCL_STATUS_SUCCESS;
   2657                }
   2658                else
   2659                {
   2660                  // Scene not found
   2661                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2662                  {
   2663                    // The Group is not in the Group Table
   2664                    status = ZCL_STATUS_INVALID_FIELD;
   2665                  }
   2666                  else
   2667                  {
   2668                    status = ZCL_STATUS_NOT_FOUND;
   2669                  }
   2670                }
   2671          
   2672                if ( UNICAST_MSG( pInMsg->msg ) )
   2673                {
   2674                  // Addressed to this device (not to a group) - send a response back
   2675                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2676                                                      status, scene.groupID,
   2677                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2678                }
   2679                stat = ZCL_STATUS_CMD_HAS_RSP;
   2680                break;
   2681          
   2682              case COMMAND_SCENE_REMOVE_ALL:
   2683                if ( scene.groupID == 0x0000 ||
   2684                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2685                {
   2686                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2687                  status = ZCL_STATUS_SUCCESS;
   2688                }
   2689                else
   2690                {
   2691                  status = ZCL_STATUS_INVALID_FIELD;
   2692                }
   2693          
   2694                if ( UNICAST_MSG( pInMsg->msg ) )
   2695                {
   2696                  // Addressed to this device (not to a group) - send a response back
   2697                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2698                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2699                }
   2700                stat = ZCL_STATUS_CMD_HAS_RSP;
   2701                break;
   2702          
   2703              case COMMAND_SCENE_STORE:
   2704                if ( scene.groupID == 0x0000 ||
   2705                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2706                {
   2707                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2708                  // does and the corresponding Group exits
   2709                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2710                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2711                  {
   2712                    uint8 sceneChanged = FALSE;
   2713          
   2714                    status = ZCL_STATUS_SUCCESS;
   2715                    if ( pScene == NULL )
   2716                    {
   2717                      // Haven't been added yet
   2718                      pScene = &scene;
   2719                    }
   2720          
   2721                    if ( pCBs->pfnSceneStoreReq )
   2722                    {
   2723                      zclSceneReq_t req;
   2724          
   2725                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2726                      req.scene = pScene;
   2727          
   2728                      // Get the latest Scene info
   2729                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2730                      {
   2731                        sceneChanged = TRUE;
   2732                      }
   2733                    }
   2734          
   2735                    if ( pScene == &scene )
   2736                    {
   2737                      // The Scene doesn't exist so add it
   2738                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2739                    }
   2740                    else if ( sceneChanged )
   2741                    {
   2742                      // The Scene already exists so update only NV
   2743                      zclGeneral_ScenesSave();
   2744                    }
   2745                  }
   2746                  else
   2747                  {
   2748                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2749                  }
   2750                }
   2751                else
   2752                {
   2753                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2754                }
   2755          
   2756                if ( UNICAST_MSG( pInMsg->msg ) )
   2757                {
   2758                  // Addressed to this device (not to a group) - send a response back
   2759                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2760                                                     status, scene.groupID, scene.ID,
   2761                                                     true, pInMsg->hdr.transSeqNum );
   2762                }
   2763                stat = ZCL_STATUS_CMD_HAS_RSP;
   2764                break;
   2765          
   2766              case COMMAND_SCENE_RECALL:
   2767                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2768                if ( pScene && pCBs->pfnSceneRecallReq )
   2769                {
   2770                  zclSceneReq_t req;
   2771          
   2772                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2773                  req.scene = pScene;
   2774          
   2775                  pCBs->pfnSceneRecallReq( &req );
   2776                }
   2777                // No response
   2778                break;
   2779          
   2780              case COMMAND_SCENE_GET_MEMBERSHIP:
   2781                // Find all the Scenes corresponding to the Group ID
   2782                if ( scene.groupID == 0x0000 ||
   2783                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2784                {
   2785                  // Allocate space for the scene list
   2786                  sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
   2787                  if ( sceneList != NULL )
   2788                  {
   2789                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2790                                                                 scene.groupID, sceneList );
   2791                    status = ZCL_STATUS_SUCCESS;
   2792                    if ( ! UNICAST_MSG( pInMsg->msg ) )
   2793                    {
   2794                      // Addressed to the Group - ONLY send a response if an entry within the
   2795                      // Scene Table corresponds to the Group ID
   2796                      if ( sceneCnt == 0 )
   2797                      {
   2798                        sendRsp = FALSE;
   2799                      }
   2800                    }
   2801                  }
   2802                  else
   2803                  {
   2804                    // Couldn't allocate space for the scene list!
   2805                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2806                  }
   2807                }
   2808                else
   2809                {
   2810                  // The Group is not in the Group Table - send a response back
   2811                  status = ZCL_STATUS_INVALID_FIELD;
   2812                }
   2813          
   2814          #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
   2815                if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
   2816          #else
   2817                if ( sendRsp )
   2818          #endif //ZCL_LIGHT_LINK_ENHANCE
   2819                {
   2820                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2821                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2822                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2823                }
   2824          
   2825                if ( sceneList != NULL )
   2826                  zcl_mem_free( sceneList );
   2827          
   2828                stat = ZCL_STATUS_CMD_HAS_RSP;
   2829                break;
   2830          
   2831          #ifdef ZCL_LIGHT_LINK_ENHANCE
   2832              case COMMAND_SCENE_COPY:
   2833                {
   2834                  uint8 mode;
   2835                  uint16 groupIDFrom, groupIDTo;
   2836                  uint8 sceneIDFrom, sceneIDTo;
   2837          
   2838                  pData = pInMsg->pData; // different payload format
   2839          
   2840                  mode = *pData++;
   2841                  groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
   2842                  pData += 2;
   2843                  sceneIDFrom = *pData++; // from scene ID
   2844                  groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
   2845                  pData += 2;
   2846                  if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
   2847                  {
   2848                    sceneIDTo = *pData++; // to scene ID
   2849                  }
   2850          
   2851                  // Make sure the groups exist
   2852                  if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
   2853                       ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
   2854                  {
   2855                    // Allocate space for the scene list
   2856                    sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
   2857                    if ( sceneList == NULL )
   2858                    {
   2859                      status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
   2860                    }
   2861                    else
   2862                    {
   2863                      status = ZCL_STATUS_SUCCESS;
   2864                      if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
   2865                      {
   2866                        sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2867                                                                     groupIDFrom, sceneList );
   2868                      }
   2869                      else // Copy single scene
   2870                      {
   2871                        // Make sure the scene exists
   2872                        pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
   2873                        if ( pScene != NULL )
   2874                        {
   2875                          sceneList[0] = sceneIDFrom;
   2876                          sceneCnt = 1;
   2877                        }
   2878                        else
   2879                        {
   2880                          status = ZCL_STATUS_INVALID_FIELD; // Scene not found
   2881                        }
   2882                      }
   2883                    }
   2884          
   2885                    if ( status == ZCL_STATUS_SUCCESS )
   2886                    {
   2887                      uint8 numScenesToAdd = 0;
   2888                      uint8 i;
   2889                      for ( i = 0; i < sceneCnt; i++ )
   2890                      {
   2891                        if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
   2892                        {
   2893                          numScenesToAdd++;
   2894                        }
   2895                      }
   2896                      if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
   2897                      {
   2898                        // Copy the scenes
   2899                        for ( i = 0; i < sceneCnt; i++ )
   2900                        {
   2901                          // Ignore scene ID from and scene ID to fields
   2902                          pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
   2903                          if ( pScene != NULL )
   2904                          {
   2905                            zclGeneral_Scene_t *pToScene;
   2906                            scene = *pScene;
   2907                            scene.groupID = groupIDTo;
   2908                            scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
   2909          
   2910                            pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2911                            if( pToScene != NULL )
   2912                            {
   2913                              zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
   2914                            }
   2915                            // Add the scene
   2916                            zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2917                          }
   2918                        }
   2919                      }
   2920                      else
   2921                      {
   2922                        status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2923                      }
   2924                    }
   2925                  }
   2926                  else
   2927                  {
   2928                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2929                  }
   2930          
   2931                  if ( UNICAST_MSG( pInMsg->msg ) )
   2932                  {
   2933                    if ( pScene == NULL )
   2934                    {
   2935                      pScene = &scene;
   2936                    }
   2937                    // Addressed to this device (not to a group) - send a response back
   2938                    zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2939                                                      status, pScene->groupID, pScene->ID,
   2940                                                      true, pInMsg->hdr.transSeqNum );
   2941                  }
   2942          
   2943                  if ( sceneList != NULL )
   2944                  {
   2945                    zcl_mem_free( sceneList );
   2946                  }
   2947                }
   2948          
   2949                stat = ZCL_STATUS_CMD_HAS_RSP;
   2950                break;
   2951          #endif // ZCL_LIGHT_LINK_ENHANCE
   2952          
   2953              default:
   2954                stat = ZFailure;
   2955              break;
   2956            }
   2957          
   2958            return ( stat );
   2959          }
   2960          
   2961          #endif // ZCL_SCENES
   2962          /*********************************************************************
   2963           * @fn      zclGeneral_ProcessInScenesClient
   2964           *
   2965           * @brief   Process in the received Scenes Command.
   2966           *
   2967           * @param   pInMsg - pointer to the incoming message
   2968           *
   2969           * @return  ZStatus_t
   2970           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2971          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInScenesClient:
   2972                                                             zclGeneral_AppCallbacks_t *pCBs )
   2973          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 70
   \   000005   74BA         MOV       A,#-0x46
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   7403         MOV       A,#0x3
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   EA           MOV       A,R2
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   EB           MOV       A,R3
   \   000013   F0           MOVX      @DPTR,A
   \   000014   7401         MOV       A,#0x1
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   EC           MOV       A,R4
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   A3           INC       DPTR
   \   00001C   ED           MOV       A,R5
   \   00001D   F0           MOVX      @DPTR,A
   2974            zclGeneral_Scene_t scene;
   2975            uint8 *pData = pInMsg->pData;
   \   00001E   7403         MOV       A,#0x3
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   12....       LCALL     ?Subroutine11 & 0xFFFF
   2976            uint8 nameLen;
   2977            zclSceneRsp_t rsp;
   2978            uint8 i;
   2979            ZStatus_t stat = ZSuccess;
   \                     ??CrossCallReturnLabel_16:
   \   000026   85..82       MOV       DPL,?XSP + 0
   \   000029   85..83       MOV       DPH,?XSP + 1
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
   2980          
   2981            zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   \   00002E                ; Setup parameters for call to function osal_memset
   \   00002E   7C37         MOV       R4,#0x37
   \   000030   FD           MOV       R5,A
   \   000031   F9           MOV       R1,A
   \   000032   740F         MOV       A,#0xf
   \   000034   12....       LCALL     ?XSTACK_DISP101_8
   \   000037   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2982            zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   \   00003A                ; Setup parameters for call to function osal_memset
   \   00003A   7C0A         MOV       R4,#0xa
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   7900         MOV       R1,#0x0
   \   000040   7405         MOV       A,#0x5
   \   000042   12....       LCALL     ?XSTACK_DISP101_8
   \   000045   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2983          
   2984            // Get the status field first
   2985            rsp.status = *pData++;
   \   000048   8E82         MOV       DPL,R6
   \   00004A   8F83         MOV       DPH,R7
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   C0E0         PUSH      A
   \   00004F   7408         MOV       A,#0x8
   \   000051   12....       LCALL     ?XSTACK_DISP0_8
   \   000054   D0E0         POP       A
   \   000056   12....       LCALL     ?Subroutine24 & 0xFFFF
   2986          
   2987            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   \                     ??CrossCallReturnLabel_35:
   \   000059   7403         MOV       A,#0x3
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000061   6406         XRL       A,#0x6
   \   000063   7017         JNZ       ??zclGeneral_ProcessInScenesClient_0
   2988            {
   2989              rsp.capacity = *pData++;
   \   000065   8E82         MOV       DPL,R6
   \   000067   8F83         MOV       DPH,R7
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   C0E0         PUSH      A
   \   00006C   740C         MOV       A,#0xc
   \   00006E   12....       LCALL     ?XSTACK_DISP0_8
   \   000071   D0E0         POP       A
   \   000073   F0           MOVX      @DPTR,A
   \   000074   8E82         MOV       DPL,R6
   \   000076   8F83         MOV       DPH,R7
   \   000078   A3           INC       DPTR
   \   000079   0E           INC       R6
   \   00007A   AF83         MOV       R7,DPH
   2990            }
   2991          
   2992            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   \                     ??zclGeneral_ProcessInScenesClient_0:
   \   00007C   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00007F   740F         MOV       A,#0xf
   \   000081   12....       LCALL     ?XSTACK_DISP0_8
   \   000084   12....       LCALL     ?Subroutine20 & 0xFFFF
   2993            pData += 2;   // Move past group ID
   \                     ??CrossCallReturnLabel_53:
   \   000087   EE           MOV       A,R6
   \   000088   2402         ADD       A,#0x2
   \   00008A   FE           MOV       R6,A
   \   00008B   5001         JNC       ??zclGeneral_ProcessInScenesClient_1
   \   00008D   0F           INC       R7
   2994          
   2995            switch ( pInMsg->hdr.commandID )
   \                     ??zclGeneral_ProcessInScenesClient_1:
   \   00008E   8E82         MOV       DPL,R6
   \   000090   8F83         MOV       DPH,R7
   \   000092   A3           INC       DPTR
   \   000093   A882         MOV       R0,DPL
   \   000095   A983         MOV       R1,DPH
   \   000097   85..82       MOV       DPL,?V6
   \   00009A   85..83       MOV       DPH,?V7
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   7003         JNZ       $+5
   \   0000A0   02....       LJMP      ??zclGeneral_ProcessInScenesClient_2 & 0xFFFF
   \   0000A3   14           DEC       A
   \   0000A4   601D         JZ        ??zclGeneral_ProcessInScenesClient_3
   \   0000A6   14           DEC       A
   \   0000A7   607C         JZ        ??zclGeneral_ProcessInScenesClient_2
   \   0000A9   14           DEC       A
   \   0000AA   6079         JZ        ??zclGeneral_ProcessInScenesClient_2
   \   0000AC   14           DEC       A
   \   0000AD   6076         JZ        ??zclGeneral_ProcessInScenesClient_2
   \   0000AF   24FE         ADD       A,#-0x2
   \   0000B1   7003         JNZ       $+5
   \   0000B3   02....       LJMP      ??zclGeneral_ProcessInScenesClient_4 & 0xFFFF
   \   0000B6   24C6         ADD       A,#-0x3a
   \   0000B8   606B         JZ        ??zclGeneral_ProcessInScenesClient_2
   \   0000BA   14           DEC       A
   \   0000BB   6006         JZ        ??zclGeneral_ProcessInScenesClient_3
   \   0000BD   14           DEC       A
   \   0000BE   6065         JZ        ??zclGeneral_ProcessInScenesClient_2
   \   0000C0   02....       LJMP      ??zclGeneral_ProcessInScenesClient_5 & 0xFFFF
   2996            {
   2997              // JC NOTE: Extend the original z-stack to let it parse enhanced view/add commands
   2998              case COMMAND_SCENE_ENHANCED_VIEW_RSP:
   2999              case COMMAND_SCENE_VIEW_RSP:
   3000                // Parse the rest of the incoming message
   3001                scene.ID = *pData++; // Not applicable to Remove All Response command
   \                     ??zclGeneral_ProcessInScenesClient_3:
   \   0000C3   8E82         MOV       DPL,R6
   \   0000C5   8F83         MOV       DPH,R7
   \   0000C7   E0           MOVX      A,@DPTR
   \   0000C8   C0E0         PUSH      A
   \   0000CA   7411         MOV       A,#0x11
   \   0000CC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CF   D0E0         POP       A
   \   0000D1   F0           MOVX      @DPTR,A
   \   0000D2   E8           MOV       A,R0
   \   0000D3   FE           MOV       R6,A
   \   0000D4   E9           MOV       A,R1
   \   0000D5   FF           MOV       R7,A
   3002                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   \   0000D6   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0000D9   7412         MOV       A,#0x12
   \   0000DB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DE   12....       LCALL     ?Subroutine20 & 0xFFFF
   3003                pData += 2;
   3004                nameLen = *pData++; // Name length
   \                     ??CrossCallReturnLabel_54:
   \   0000E1   8E82         MOV       DPL,R6
   \   0000E3   8F83         MOV       DPH,R7
   \   0000E5   A3           INC       DPTR
   \   0000E6   A3           INC       DPTR
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   F5..         MOV       ?V3,A
   \   0000EA   EE           MOV       A,R6
   \   0000EB   2403         ADD       A,#0x3
   \   0000ED   FE           MOV       R6,A
   \   0000EE   5001         JNC       ??zclGeneral_ProcessInScenesClient_6
   \   0000F0   0F           INC       R7
   3005                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   \                     ??zclGeneral_ProcessInScenesClient_6:
   \   0000F1   E5..         MOV       A,?V3
   \   0000F3   C3           CLR       C
   \   0000F4   9410         SUBB      A,#0x10
   \   0000F6   4003         JC        ??zclGeneral_ProcessInScenesClient_7
   3006                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   \   0000F8   75..0F       MOV       ?V3,#0xf
   3007          
   3008                scene.name[0] = nameLen;
   \                     ??zclGeneral_ProcessInScenesClient_7:
   \   0000FB   7416         MOV       A,#0x16
   \   0000FD   12....       LCALL     ?XSTACK_DISP0_8
   \   000100   E5..         MOV       A,?V3
   \   000102   12....       LCALL     ?Subroutine23 & 0xFFFF
   3009                zcl_memcpy( &(scene.name[1]), pData, nameLen );
   \                     ??CrossCallReturnLabel_34:
   \   000105   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000108   AC..         MOV       R4,?V3
   \   00010A   7D00         MOV       R5,#0x0
   \   00010C   741A         MOV       A,#0x1a
   \   00010E   12....       LCALL     ?XSTACK_DISP0_8
   \   000111   AA82         MOV       R2,DPL
   \   000113   AB83         MOV       R3,DPH
   \   000115   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000118   7403         MOV       A,#0x3
   \   00011A   12....       LCALL     ?DEALLOC_XSTACK8
   3010          
   3011                pData += nameLen; // move past name, use original length
   \   00011D   A8..         MOV       R0,?V3
   \   00011F   EE           MOV       A,R6
   \   000120   28           ADD       A,R0
   \   000121   FE           MOV       R6,A
   \   000122   E4           CLR       A
   \   000123   3F           ADDC      A,R7
   \   000124   FF           MOV       R7,A
   3012          
   3013                //*** Do something with the extension field(s)
   3014          
   3015                // Fall through to callback - break is left off intentionally
   3016              case COMMAND_SCENE_ADD_RSP:
   3017              // JC NOTE: Extend the original z-stack to let it parse enhanced view/add commands
   3018              case COMMAND_SCENE_ENHANCED_ADD_RSP:
   3019              case COMMAND_SCENE_REMOVE_RSP:
   3020              case COMMAND_SCENE_REMOVE_ALL_RSP:
   3021              case COMMAND_SCENE_STORE_RSP:
   3022              // JC NOTE: Extend the original z-stack to let it parse Copy Scene Response command.
   3023              // The intuition is that the payload for the command is the same as COMMAND_SCNE_ADD_RSP
   3024              case COMMAND_SCENE_COPY_RSP:
   3025                if ( pCBs->pfnSceneRsp )
   \                     ??zclGeneral_ProcessInScenesClient_2:
   \   000125   7401         MOV       A,#0x1
   \   000127   12....       LCALL     ?XSTACK_DISP0_8
   \   00012A   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00012D   7003         JNZ       $+5
   \   00012F   02....       LJMP      ??zclGeneral_ProcessInScenesClient_8 & 0xFFFF
   3026                {
   3027                  if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
   \   000132   85..82       MOV       DPL,?V6
   \   000135   85..83       MOV       DPH,?V7
   \   000138   E0           MOVX      A,@DPTR
   \   000139   6403         XRL       A,#0x3
   \   00013B   600F         JZ        ??zclGeneral_ProcessInScenesClient_9
   3028                  {
   3029                    scene.ID = *pData++;
   \   00013D   8E82         MOV       DPL,R6
   \   00013F   8F83         MOV       DPH,R7
   \   000141   E0           MOVX      A,@DPTR
   \   000142   C0E0         PUSH      A
   \   000144   7411         MOV       A,#0x11
   \   000146   12....       LCALL     ?XSTACK_DISP0_8
   \   000149   D0E0         POP       A
   \   00014B   F0           MOVX      @DPTR,A
   3030                  }
   3031                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \                     ??zclGeneral_ProcessInScenesClient_9:
   \   00014C   7403         MOV       A,#0x3
   \   00014E   12....       LCALL     ?XSTACK_DISP0_8
   \   000151   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000154   12....       LCALL     ?XSTACK_DISP0_8
   \   000157   12....       LCALL     ?Subroutine18 & 0xFFFF
   3032                  rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_25:
   \   00015A   C0E0         PUSH      A
   \   00015C   7407         MOV       A,#0x7
   \   00015E   12....       LCALL     ?XSTACK_DISP0_8
   \   000161   D0E0         POP       A
   \   000163   F0           MOVX      @DPTR,A
   3033                  rsp.scene = &scene;
   \   000164   740F         MOV       A,#0xf
   \   000166   12....       LCALL     ?XSTACK_DISP100_8
   \   000169   740D         MOV       A,#0xd
   \   00016B   12....       LCALL     ?XSTACK_DISP0_8
   \   00016E   12....       LCALL     ?Subroutine20 & 0xFFFF
   3034          
   3035                  pCBs->pfnSceneRsp( &rsp );
   \                     ??CrossCallReturnLabel_55:
   \   000171                ; Setup parameters for indirect call
   \   000171   7405         MOV       A,#0x5
   \   000173   12....       LCALL     ?XSTACK_DISP101_8
   \   000176   7401         MOV       A,#0x1
   \   000178   12....       LCALL     ?XSTACK_DISP0_8
   \   00017B   12....       LCALL     ?Subroutine6 & 0xFFFF
   3036                }
   \                     ??CrossCallReturnLabel_5:
   \   00017E   12....       LCALL     ?CALL_IND
   \   000181   02....       LJMP      ??zclGeneral_ProcessInScenesClient_8 & 0xFFFF
   3037                break;
   3038          
   3039              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   3040                {
   3041                  uint8 *sceneList = NULL;
   \                     ??zclGeneral_ProcessInScenesClient_4:
   \   000184   75..00       MOV       ?V0,#0x0
   \   000187   75..00       MOV       ?V1,#0x0
   3042          
   3043                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   \   00018A   7408         MOV       A,#0x8
   \   00018C   12....       LCALL     ?XSTACK_DISP0_8
   \   00018F   E0           MOVX      A,@DPTR
   \   000190   7048         JNZ       ??zclGeneral_ProcessInScenesClient_10
   3044                  {
   3045                    uint8 sceneCnt = *pData++;
   \   000192   8E82         MOV       DPL,R6
   \   000194   8F83         MOV       DPH,R7
   \   000196   E0           MOVX      A,@DPTR
   \   000197   F5..         MOV       ?V2,A
   \   000199   E8           MOV       A,R0
   \   00019A   FE           MOV       R6,A
   \   00019B   E9           MOV       A,R1
   \   00019C   FF           MOV       R7,A
   3046          
   3047                    if ( sceneCnt > 0 )
   \   00019D   E5..         MOV       A,?V2
   \   00019F   6039         JZ        ??zclGeneral_ProcessInScenesClient_10
   3048                    {
   3049                      // Allocate space for the scene list
   3050                      sceneList = zcl_mem_alloc( sceneCnt );
   \   0001A1                ; Setup parameters for call to function osal_mem_alloc
   \   0001A1   FA           MOV       R2,A
   \   0001A2   7B00         MOV       R3,#0x0
   \   0001A4   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0001A7   8A..         MOV       ?V0,R2
   \   0001A9   8B..         MOV       ?V1,R3
   3051                      if ( sceneList != NULL )
   \   0001AB   EA           MOV       A,R2
   \   0001AC   45..         ORL       A,?V1
   \   0001AE   602A         JZ        ??zclGeneral_ProcessInScenesClient_10
   3052                      {
   3053                        rsp.sceneCnt = sceneCnt;
   \   0001B0   7409         MOV       A,#0x9
   \   0001B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0001B5   E5..         MOV       A,?V2
   \   0001B7   F0           MOVX      @DPTR,A
   3054                        for ( i = 0; i < sceneCnt; i++ )
   \   0001B8   7800         MOV       R0,#0x0
   \   0001BA   8018         SJMP      ??zclGeneral_ProcessInScenesClient_11
   3055                          sceneList[i] = *pData++;
   \                     ??zclGeneral_ProcessInScenesClient_12:
   \   0001BC   8E82         MOV       DPL,R6
   \   0001BE   8F83         MOV       DPH,R7
   \   0001C0   E0           MOVX      A,@DPTR
   \   0001C1   C0E0         PUSH      A
   \   0001C3   E8           MOV       A,R0
   \   0001C4   FA           MOV       R2,A
   \   0001C5   E5..         MOV       A,?V0
   \   0001C7   2A           ADD       A,R2
   \   0001C8   F582         MOV       DPL,A
   \   0001CA   E4           CLR       A
   \   0001CB   3B           ADDC      A,R3
   \   0001CC   F583         MOV       DPH,A
   \   0001CE   D0E0         POP       A
   \   0001D0   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0001D3   08           INC       R0
   \                     ??zclGeneral_ProcessInScenesClient_11:
   \   0001D4   E8           MOV       A,R0
   \   0001D5   C3           CLR       C
   \   0001D6   95..         SUBB      A,?V2
   \   0001D8   40E2         JC        ??zclGeneral_ProcessInScenesClient_12
   3056                      }
   3057                    }
   3058                  }
   3059          
   3060                  if ( pCBs->pfnSceneRsp )
   \                     ??zclGeneral_ProcessInScenesClient_10:
   \   0001DA   7401         MOV       A,#0x1
   \   0001DC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001DF   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0001E2   6041         JZ        ??zclGeneral_ProcessInScenesClient_13
   3061                  {
   3062                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   0001E4   7403         MOV       A,#0x3
   \   0001E6   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E9   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0001EC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001EF   12....       LCALL     ?Subroutine18 & 0xFFFF
   3063                    rsp.cmdID = pInMsg->hdr.commandID;
   \                     ??CrossCallReturnLabel_26:
   \   0001F2   C0E0         PUSH      A
   \   0001F4   7407         MOV       A,#0x7
   \   0001F6   12....       LCALL     ?XSTACK_DISP0_8
   \   0001F9   D0E0         POP       A
   \   0001FB   F0           MOVX      @DPTR,A
   3064                    rsp.sceneList = sceneList;
   \   0001FC   740A         MOV       A,#0xa
   \   0001FE   12....       LCALL     ?XSTACK_DISP0_8
   \   000201   E5..         MOV       A,?V0
   \   000203   F0           MOVX      @DPTR,A
   \   000204   A3           INC       DPTR
   \   000205   E5..         MOV       A,?V1
   \   000207   F0           MOVX      @DPTR,A
   3065                    rsp.scene = &scene;
   \   000208   740F         MOV       A,#0xf
   \   00020A   12....       LCALL     ?XSTACK_DISP100_8
   \   00020D   740D         MOV       A,#0xd
   \   00020F   12....       LCALL     ?XSTACK_DISP0_8
   \   000212   12....       LCALL     ?Subroutine20 & 0xFFFF
   3066          
   3067                    pCBs->pfnSceneRsp( &rsp);
   \                     ??CrossCallReturnLabel_56:
   \   000215                ; Setup parameters for indirect call
   \   000215   7405         MOV       A,#0x5
   \   000217   12....       LCALL     ?XSTACK_DISP101_8
   \   00021A   7401         MOV       A,#0x1
   \   00021C   12....       LCALL     ?XSTACK_DISP0_8
   \   00021F   12....       LCALL     ?Subroutine6 & 0xFFFF
   3068                  }
   \                     ??CrossCallReturnLabel_6:
   \   000222   12....       LCALL     ?CALL_IND
   3069          
   3070                  if ( sceneList != NULL )
   \                     ??zclGeneral_ProcessInScenesClient_13:
   \   000225   E5..         MOV       A,?V0
   \   000227   45..         ORL       A,?V1
   \   000229   6012         JZ        ??zclGeneral_ProcessInScenesClient_8
   3071                  {
   3072                    zcl_mem_free( sceneList );
   \   00022B                ; Setup parameters for call to function osal_mem_free
   \   00022B   AA..         MOV       R2,?V0
   \   00022D   AB..         MOV       R3,?V1
   \   00022F   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000232   8009         SJMP      ??zclGeneral_ProcessInScenesClient_8
   3073                  }
   3074                }
   3075                break;
   3076          
   3077              default:
   3078                stat = ZFailure;
   \                     ??zclGeneral_ProcessInScenesClient_5:
   \   000234   85..82       MOV       DPL,?XSP + 0
   \   000237   85..83       MOV       DPH,?XSP + 1
   \   00023A   7401         MOV       A,#0x1
   \   00023C   F0           MOVX      @DPTR,A
   3079                break;
   3080            }
   3081          
   3082            return ( stat );
   \                     ??zclGeneral_ProcessInScenesClient_8:
   \   00023D   85..82       MOV       DPL,?XSP + 0
   \   000240   85..83       MOV       DPH,?XSP + 1
   \   000243   E0           MOVX      A,@DPTR
   \   000244   F9           MOV       R1,A
   \   000245   7446         MOV       A,#0x46
   \   000247   02....       LJMP      ?Subroutine3 & 0xFFFF
   3083          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   AE82         MOV       R6,DPL
   \   000008   AF83         MOV       R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine35_0
   \   000004                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   7405         MOV       A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   49           ORL       A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000003   F583         MOV       DPH,A
   \   000005   8882         MOV       DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000003   C8           XCH       A,R0
   \   000004   240E         ADD       A,#0xe
   \   000006   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000009   22           RET
   3084          
   3085          #ifdef ZCL_ON_OFF
   3086          /*********************************************************************
   3087           * @fn      zclGeneral_ProcessInCmdOnOff
   3088           *
   3089           * @brief   Process in the received On/Off Command.
   3090           *
   3091           * @param   pInMsg - pointer to the incoming message
   3092           *
   3093           * @return  ZStatus_t
   3094           */
   3095          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   3096                                                      zclGeneral_AppCallbacks_t *pCBs )
   3097          {
   3098            ZStatus_t stat = ZSuccess;
   3099          
   3100            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3101            {
   3102              switch ( pInMsg->hdr.commandID )
   3103              {
   3104                case COMMAND_OFF:
   3105                case COMMAND_ON:
   3106                case COMMAND_TOGGLE:
   3107                  if ( pCBs->pfnOnOff )
   3108                  {
   3109                    pCBs->pfnOnOff( pInMsg->hdr.commandID );
   3110                  }
   3111                  break;
   3112          
   3113          #ifdef ZCL_LIGHT_LINK_ENHANCE
   3114                case COMMAND_OFF_WITH_EFFECT:
   3115                  if ( pCBs->pfnOnOff_OffWithEffect )
   3116                  {
   3117                    zclOffWithEffect_t cmd;
   3118          
   3119                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3120                    cmd.effectId = pInMsg->pData[0];
   3121                    cmd.effectVariant = pInMsg->pData[1];
   3122          
   3123                    pCBs->pfnOnOff_OffWithEffect( &cmd );
   3124                  }
   3125                  break;
   3126          
   3127                case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
   3128                  if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
   3129                  {
   3130                    pCBs->pfnOnOff_OnWithRecallGlobalScene();
   3131                  }
   3132                  break;
   3133          
   3134                case COMMAND_ON_WITH_TIMED_OFF:
   3135                  if ( pCBs->pfnOnOff_OnWithTimedOff )
   3136                  {
   3137                    zclOnWithTimedOff_t cmd;
   3138          
   3139                    cmd.onOffCtrl.byte = pInMsg->pData[0];
   3140                    cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3141                    cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
   3142                    pCBs->pfnOnOff_OnWithTimedOff( &cmd );
   3143                  }
   3144                  break;
   3145          #endif // ZCL_LIGHT_LINK_ENHANCE
   3146          
   3147                default:
   3148                  stat = ZFailure;
   3149                  break;
   3150              }
   3151            }
   3152            // no Client command
   3153          
   3154            return ( stat );
   3155          }
   3156          #endif // ZCL_ON_OFF
   3157          
   3158          #ifdef ZCL_LEVEL_CTRL
   3159          /*********************************************************************
   3160           * @fn      zclGeneral_ProcessInLevelControl
   3161           *
   3162           * @brief   Process in the received Level Control Command.
   3163           *
   3164           * @param   pInMsg - pointer to the incoming message
   3165           *
   3166           * @return  ZStatus_t
   3167           */
   3168          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   3169                                                             zclGeneral_AppCallbacks_t *pCBs )
   3170          {
   3171            uint8 withOnOff = FALSE;
   3172            ZStatus_t stat = ZSuccess;
   3173          
   3174            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   3175            {
   3176              switch ( pInMsg->hdr.commandID )
   3177              {
   3178                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   3179                  withOnOff = TRUE;
   3180                  // fall through
   3181                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   3182                  if ( pCBs->pfnLevelControlMoveToLevel )
   3183                  {
   3184                    zclLCMoveToLevel_t cmd;
   3185          
   3186                    cmd.level = pInMsg->pData[0];
   3187          
   3188                    if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
   3189                         ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
   3190                    {
   3191                      cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   3192                      cmd.withOnOff = withOnOff;
   3193          
   3194                      pCBs->pfnLevelControlMoveToLevel( &cmd );
   3195                    }
   3196                    else
   3197                    {
   3198                      // level range requested is invalid
   3199                      stat = ZCL_STATUS_INVALID_VALUE;
   3200                    }
   3201                  }
   3202                  break;
   3203          
   3204                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   3205                  withOnOff = TRUE;
   3206                  // fall through
   3207                case COMMAND_LEVEL_MOVE:
   3208                  if ( pCBs->pfnLevelControlMove )
   3209                  {
   3210                    zclLCMove_t cmd;
   3211          
   3212                    cmd.moveMode = pInMsg->pData[0];
   3213                    cmd.rate = pInMsg->pData[1];
   3214                    cmd.withOnOff = withOnOff;
   3215          
   3216                    pCBs->pfnLevelControlMove( &cmd );
   3217                  }
   3218                  break;
   3219          
   3220                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   3221                  withOnOff = TRUE;
   3222                  // fall through
   3223                case COMMAND_LEVEL_STEP:
   3224                  if ( pCBs->pfnLevelControlStep )
   3225                  {
   3226                    zclLCStep_t cmd;
   3227          
   3228                    cmd.stepMode = pInMsg->pData[0];
   3229                    cmd.amount =  pInMsg->pData[1];
   3230                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   3231                    cmd.withOnOff = withOnOff;
   3232          
   3233                    pCBs->pfnLevelControlStep( &cmd );
   3234                  }
   3235                  break;
   3236          
   3237                case COMMAND_LEVEL_STOP:
   3238                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   3239                  // Both Stop commands are identical
   3240                  if ( pCBs->pfnLevelControlStop )
   3241                  {
   3242                    pCBs->pfnLevelControlStop();
   3243                  }
   3244                  break;
   3245          
   3246                default:
   3247                  stat = ZFailure;
   3248                  break;
   3249              }
   3250            }
   3251            // no Client command
   3252          
   3253            return ( stat );
   3254          }
   3255          #endif // ZCL_LEVEL_CTRL
   3256          
   3257          #ifdef ZCL_ALARMS
   3258          /*********************************************************************
   3259           * @fn      zclGeneral_AddAlarm
   3260           *
   3261           * @brief   Add an alarm for a cluster
   3262           *
   3263           * @param   endpoint -
   3264           * @param   alarm - new alarm item
   3265           *
   3266           * @return  ZStatus_t
   3267           */
   3268          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   3269          {
   3270            zclGenAlarmItem_t *pNewItem;
   3271            zclGenAlarmItem_t *pLoop;
   3272          
   3273            // Fill in the new profile list
   3274            pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   3275            if ( pNewItem == NULL )
   3276              return ( ZMemError );
   3277          
   3278            // Fill in the plugin record.
   3279            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   3280            pNewItem->endpoint =  endpoint;
   3281            zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   3282          
   3283            // Find spot in list
   3284            if (  zclGenAlarmTable == NULL )
   3285            {
   3286              zclGenAlarmTable = pNewItem;
   3287            }
   3288            else
   3289            {
   3290              // Look for end of list
   3291              pLoop = zclGenAlarmTable;
   3292              while ( pLoop->next != NULL )
   3293                pLoop = pLoop->next;
   3294          
   3295              // Put new item at end of list
   3296              pLoop->next = pNewItem;
   3297            }
   3298          
   3299            return ( ZSuccess );
   3300          }
   3301          
   3302          /*********************************************************************
   3303           * @fn      zclGeneral_FindAlarm
   3304           *
   3305           * @brief   Find an alarm with alarmCode and clusterID
   3306           *
   3307           * @param   endpoint -
   3308           * @param   groupID - what group the scene belongs to
   3309           * @param   sceneID - ID to look for scene
   3310           *
   3311           * @return  a pointer to the alarm information, NULL if not found
   3312           */
   3313          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3314          {
   3315            zclGenAlarmItem_t *pLoop;
   3316          
   3317            // Look for the alarm
   3318            pLoop = zclGenAlarmTable;
   3319            while ( pLoop )
   3320            {
   3321              if ( pLoop->endpoint == endpoint &&
   3322                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3323              {
   3324                return ( &(pLoop->alarm) );
   3325              }
   3326              pLoop = pLoop->next;
   3327            }
   3328          
   3329            return ( (zclGeneral_Alarm_t *)NULL );
   3330          }
   3331          
   3332          /*********************************************************************
   3333           * @fn      zclGeneral_FindEarliestAlarm
   3334           *
   3335           * @brief   Find an alarm with the earliest timestamp
   3336           *
   3337           * @param   endpoint -
   3338           *
   3339           * @return  a pointer to the alarm information, NULL if not found
   3340           */
   3341          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   3342          {
   3343            zclGenAlarmItem_t *pLoop;
   3344            zclGenAlarmItem_t earliestAlarm;
   3345            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   3346          
   3347            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   3348          
   3349            // Look for alarm with earliest time
   3350            pLoop = zclGenAlarmTable;
   3351            while ( pLoop )
   3352            {
   3353              if ( pLoop->endpoint == endpoint &&
   3354                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   3355              {
   3356                pEarliestAlarm = pLoop;
   3357              }
   3358              pLoop = pLoop->next;
   3359            }
   3360          
   3361            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   3362              return ( &(pEarliestAlarm->alarm) );
   3363          
   3364            // No alarm
   3365            return ( (zclGeneral_Alarm_t *)NULL );
   3366          }
   3367          
   3368          /*********************************************************************
   3369           * @fn      zclGeneral_ResetAlarm
   3370           *
   3371           * @brief   Remove an alarm with alarmCode and clusterID
   3372           *
   3373           * @param   endpoint -
   3374           * @param   alarmCode -
   3375           * @param   clusterID -
   3376           *
   3377           * @return  TRUE if removed, FALSE if not found
   3378           */
   3379          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   3380          {
   3381            zclGenAlarmItem_t *pLoop;
   3382            zclGenAlarmItem_t *pPrev;
   3383          
   3384            // Look for end of list
   3385            pLoop = zclGenAlarmTable;
   3386            pPrev = NULL;
   3387            while ( pLoop )
   3388            {
   3389              if ( pLoop->endpoint == endpoint &&
   3390                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   3391              {
   3392                if ( pPrev == NULL )
   3393                  zclGenAlarmTable = pLoop->next;
   3394                else
   3395                  pPrev->next = pLoop->next;
   3396          
   3397                // Free the memory
   3398                zcl_mem_free( pLoop );
   3399          
   3400                // Notify the Application so that if the alarm condition still active then
   3401                // a new notification will be generated, and a new alarm record will be
   3402                // added to the alarm log
   3403                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   3404                return;
   3405              }
   3406              pPrev = pLoop;
   3407              pLoop = pLoop->next;
   3408            }
   3409          }
   3410          
   3411          /*********************************************************************
   3412           * @fn      zclGeneral_ResetAllAlarms
   3413           *
   3414           * @brief   Remove all alarms with endpoint
   3415           *
   3416           * @param   endpoint -
   3417           * @param   notifyApp -
   3418           *
   3419           * @return  none
   3420           */
   3421          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   3422          {
   3423            zclGenAlarmItem_t *pLoop;
   3424            zclGenAlarmItem_t *pPrev;
   3425            zclGenAlarmItem_t *pNext;
   3426          
   3427            // Look for end of list
   3428            pLoop = zclGenAlarmTable;
   3429            pPrev = NULL;
   3430            while ( pLoop )
   3431            {
   3432              if (  pLoop->endpoint == endpoint )
   3433              {
   3434                if ( pPrev == NULL )
   3435                  zclGenAlarmTable = pLoop->next;
   3436                else
   3437                  pPrev->next = pLoop->next;
   3438          
   3439                pNext = pLoop->next;
   3440          
   3441                // Free the memory
   3442                zcl_mem_free( pLoop );
   3443          
   3444                pLoop = pNext;
   3445              }
   3446              else
   3447              {
   3448                pPrev = pLoop;
   3449                pLoop = pLoop->next;
   3450              }
   3451            }
   3452          
   3453            if ( notifyApp )
   3454            {
   3455              // Notify the Application so that if any alarm conditions still active then
   3456              // a new notification will be generated, and a new alarm record will be
   3457              // added to the alarm log
   3458              // zclGeneral_NotifyResetAll(); // callback function?
   3459            }
   3460          }
   3461          
   3462          /*********************************************************************
   3463           * @fn      zclGeneral_ProcessInAlarmsServer
   3464           *
   3465           * @brief   Process in the received Alarms Command.
   3466           *
   3467           * @param   pInMsg - pointer to the incoming message
   3468           *
   3469           * @return  ZStatus_t
   3470           */
   3471          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   3472                                                             zclGeneral_AppCallbacks_t *pCBs )
   3473          {
   3474            zclAlarm_t alarm;
   3475            zclGeneral_Alarm_t *pAlarm;
   3476            uint8 *pData = pInMsg->pData;
   3477            ZStatus_t stat = ZSuccess;
   3478          
   3479            switch ( pInMsg->hdr.commandID )
   3480            {
   3481              case COMMAND_ALARMS_RESET:
   3482                if ( pCBs->pfnAlarm )
   3483                {
   3484                  alarm.cmdID = pInMsg->hdr.commandID;
   3485                  alarm.alarmCode = pData[0];
   3486                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3487          
   3488                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3489                }
   3490                else
   3491                {
   3492                  stat = ZCL_STATUS_FAILURE;
   3493                }
   3494                break;
   3495          
   3496              case COMMAND_ALARMS_RESET_ALL:
   3497                if ( pCBs->pfnAlarm )
   3498                {
   3499                  alarm.cmdID = pInMsg->hdr.commandID;
   3500          
   3501                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3502                }
   3503                else
   3504                {
   3505                  stat = ZCL_STATUS_FAILURE;
   3506                }
   3507                break;
   3508          
   3509              case COMMAND_ALARMS_GET:
   3510                if ( pCBs->pfnAlarm )
   3511                {
   3512                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3513                  alarm.cmdID = pInMsg->hdr.commandID;
   3514          
   3515                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3516          
   3517                  pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   3518                  if ( pAlarm )
   3519                  {
   3520                    // Send a response back
   3521                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3522                                                     ZCL_STATUS_SUCCESS, pAlarm->code,
   3523                                                     pAlarm->clusterID, pAlarm->timeStamp,
   3524                                                     true, pInMsg->hdr.transSeqNum );
   3525                    // Remove the entry from the Alarm table
   3526                    zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   3527                  }
   3528                  else
   3529                  {
   3530                    // Send a response back
   3531                    zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3532                                                     ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   3533                                                     true, pInMsg->hdr.transSeqNum );
   3534                  }
   3535                  stat = ZCL_STATUS_CMD_HAS_RSP;
   3536                }
   3537                else
   3538                {
   3539                  stat = ZCL_STATUS_FAILURE;
   3540                }
   3541                break;
   3542          
   3543              case COMMAND_ALARMS_RESET_LOG:
   3544                if ( pCBs->pfnAlarm )
   3545                {
   3546                  alarm.cmdID = pInMsg->hdr.commandID;
   3547          
   3548                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3549          
   3550                  zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   3551                }
   3552                else
   3553                {
   3554                  stat = ZCL_STATUS_FAILURE;
   3555                }
   3556                break;
   3557          
   3558          #ifdef SE_UK_EXT
   3559              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   3560                if ( pCBs->pfnPublishEventLog )
   3561                {
   3562                  zclPublishEventLog_t eventLog;
   3563          
   3564                  eventLog.logID = *pData++;
   3565                  eventLog.cmdIndex = *pData++;
   3566                  eventLog.totalCmds = *pData++;
   3567          
   3568                  // First try to find out number of Sub Log Payloads
   3569                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   3570                  if ( eventLog.numSubLogs > 0 )
   3571                  {
   3572                    // Try to alloc space for Log Payload
   3573                    eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
   3574                                                                             eventLog.numSubLogs );
   3575                    if ( eventLog.pLogs != NULL )
   3576                    {
   3577                      // Copy Log Payload
   3578                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   3579                      {
   3580                        eventLog.pLogs[i].eventId = *pData++;
   3581                        eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
   3582                        pData += 4;
   3583                      }
   3584                    }
   3585                    else
   3586                    {
   3587                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   3588                    }
   3589                  }
   3590                  else
   3591                  {
   3592                    eventLog.pLogs = NULL;
   3593                  }
   3594          
   3595                  if ( stat == ZSuccess )
   3596                  {
   3597                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   3598                  }
   3599          
   3600                  if ( eventLog.pLogs != NULL )
   3601                  {
   3602                    zcl_mem_free( eventLog.pLogs );
   3603                  }
   3604                }
   3605                break;
   3606          #endif // SE_UK_EXT
   3607          
   3608              default:
   3609                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3610                break;
   3611            }
   3612          
   3613            return ( stat );
   3614          }
   3615          
   3616          /*********************************************************************
   3617           * @fn      zclGeneral_ProcessInAlarmsClient
   3618           *
   3619           * @brief   Process in the received Alarms Command.
   3620           *
   3621           * @param   pInMsg - pointer to the incoming message
   3622           *
   3623           * @return  ZStatus_t
   3624           */
   3625          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   3626                                                             zclGeneral_AppCallbacks_t *pCBs )
   3627          {
   3628            uint8 *pData = pInMsg->pData;
   3629            zclAlarm_t alarm;
   3630            ZStatus_t stat = ZSuccess;
   3631          
   3632            zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   3633          
   3634            switch ( pInMsg->hdr.commandID )
   3635            {
   3636              case COMMAND_ALARMS_ALARM:
   3637                if ( pCBs->pfnAlarm )
   3638                {
   3639                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3640                  alarm.cmdID = pInMsg->hdr.commandID;
   3641                  alarm.alarmCode = pData[0];
   3642                  alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
   3643          
   3644                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3645                }
   3646                else
   3647                {
   3648                  stat = ZCL_STATUS_FAILURE;
   3649                }
   3650                break;
   3651          
   3652              case COMMAND_ALARMS_GET_RSP:
   3653                if ( pCBs->pfnAlarm )
   3654                {
   3655                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   3656                  alarm.cmdID = pInMsg->hdr.commandID;
   3657                  alarm.alarmCode = *pData++;
   3658                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   3659          
   3660                  pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
   3661                }
   3662                else
   3663                {
   3664                  stat = ZCL_STATUS_FAILURE;
   3665                }
   3666                break;
   3667          
   3668          #ifdef SE_UK_EXT
   3669              case COMMAND_ALARMS_GET_EVENT_LOG:
   3670                if ( pCBs->pfnGetEventLog )
   3671                {
   3672                  zclGetEventLog_t eventLog;
   3673          
   3674                  eventLog.logID = *pData++;
   3675                  eventLog.startTime = zcl_build_uint32( pData, 4 );
   3676                  pData += 4;
   3677                  eventLog.endTime = zcl_build_uint32( pData, 4 );
   3678                  pData += 4;
   3679                  eventLog.numEvents = *pData;
   3680          
   3681                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3682                                        &eventLog, pInMsg->hdr.transSeqNum );
   3683                }
   3684                break;
   3685          #endif // SE_UK_EXT
   3686          
   3687              default:
   3688                stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   3689                break;
   3690            }
   3691          
   3692            return ( stat );
   3693          }
   3694          #endif // ZCL_ALARMS
   3695          
   3696          #ifdef ZCL_LOCATION
   3697          /*********************************************************************
   3698           * @fn      zclGeneral_ProcessInLocationServer
   3699           *
   3700           * @brief   Process in the received Location Command.
   3701           *
   3702           * @param   pInMsg - pointer to the incoming message
   3703           *
   3704           * @return  ZStatus_t
   3705           */
   3706          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3707                                                               zclGeneral_AppCallbacks_t *pCBs )
   3708          {
   3709            uint8 *pData = pInMsg->pData;
   3710            zclLocation_t cmd;
   3711            ZStatus_t stat = ZSuccess;
   3712          
   3713            zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3714          
   3715            switch ( pInMsg->hdr.commandID )
   3716            {
   3717              case COMMAND_LOCATION_SET_ABSOLUTE:
   3718                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3719                pData += 2;
   3720                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3721                pData += 2;
   3722                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3723                pData += 2;
   3724                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3725                pData += 2;
   3726                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3727          
   3728                if ( pCBs->pfnLocation )
   3729                {
   3730                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3731                  cmd.cmdID = pInMsg->hdr.commandID;
   3732          
   3733                  // Update the absolute location info
   3734                  pCBs->pfnLocation( &cmd );
   3735                }
   3736                break;
   3737          
   3738              case COMMAND_LOCATION_SET_DEV_CFG:
   3739                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3740                pData += 2;
   3741                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3742                pData += 2;
   3743                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3744                pData += 2;
   3745                cmd.un.devCfg.numMeasurements = *pData++;
   3746                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3747          
   3748                if ( pCBs->pfnLocation )
   3749                {
   3750                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3751                  cmd.cmdID = pInMsg->hdr.commandID;
   3752          
   3753                  // Update the device configuration info
   3754                  pCBs->pfnLocation( &cmd );
   3755                }
   3756                break;
   3757          
   3758              case COMMAND_LOCATION_GET_DEV_CFG:
   3759                cmd.un.ieeeAddr = pData;
   3760          
   3761                if ( pCBs->pfnLocation )
   3762                {
   3763                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3764                  cmd.cmdID = pInMsg->hdr.commandID;
   3765                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3766          
   3767                  // Retreive the Device Configuration
   3768                  pCBs->pfnLocation( &cmd );
   3769                }
   3770                stat = ZCL_STATUS_CMD_HAS_RSP;
   3771                break;
   3772          
   3773              case COMMAND_LOCATION_GET_DATA:
   3774                cmd.un.loc.bitmap.locByte = *pData++;
   3775                cmd.un.loc.numResponses = *pData++;
   3776          
   3777                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3778                  zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
   3779          
   3780                if ( pCBs->pfnLocation )
   3781                {
   3782                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3783                  cmd.cmdID = pInMsg->hdr.commandID;
   3784                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3785          
   3786                  // Retreive the Location Data
   3787                  pCBs->pfnLocation( &cmd );
   3788                }
   3789                stat = ZCL_STATUS_CMD_HAS_RSP;
   3790                break;
   3791          
   3792              default:
   3793                stat = ZFailure;
   3794                break;
   3795            }
   3796          
   3797            return ( stat );
   3798          }
   3799          
   3800          /*********************************************************************
   3801           * @fn      zclGeneral_ProcessInLocationDataRsp
   3802           *
   3803           * @brief   Process in the received Location Command.
   3804           *
   3805           * @param   pInMsg - pointer to the incoming message
   3806           *
   3807           * @return  ZStatus_t
   3808           */
   3809          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3810                                                           zclGeneral_AppCallbacks_t *pCBs )
   3811          {
   3812            uint8 *pData = pInMsg->pData;
   3813            zclLocationRsp_t rsp;
   3814          
   3815            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3816          
   3817            if ( pCBs->pfnLocationRsp )
   3818            {
   3819              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3820                rsp.un.loc.status = *pData++;
   3821          
   3822              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3823                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3824              {
   3825                rsp.un.loc.data.type = *pData++;
   3826                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3827                pData += 2;
   3828                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3829                pData += 2;
   3830          
   3831                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3832                {
   3833                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3834                  pData += 2;
   3835                }
   3836          
   3837                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3838                {
   3839                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3840                  pData += 2;
   3841                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3842                  pData += 2;
   3843                }
   3844          
   3845                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3846                {
   3847                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3848                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3849          
   3850                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3851                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3852                }
   3853              }
   3854          
   3855              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3856              rsp.cmdID = pInMsg->hdr.commandID;
   3857          
   3858              // Notify the Application
   3859              pCBs->pfnLocationRsp( &rsp );
   3860            }
   3861          }
   3862          
   3863          /*********************************************************************
   3864           * @fn      zclGeneral_ProcessInLocationClient
   3865           *
   3866           * @brief   Process in the received Location Command.
   3867           *
   3868           * @param   pInMsg - pointer to the incoming message
   3869           *
   3870           * @return  ZStatus_t
   3871           */
   3872          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3873                                                               zclGeneral_AppCallbacks_t *pCBs )
   3874          {
   3875            uint8 *pData = pInMsg->pData;
   3876            zclLocationRsp_t rsp;
   3877            ZStatus_t stat = ZSuccess;
   3878          
   3879            zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3880          
   3881            switch ( pInMsg->hdr.commandID )
   3882            {
   3883              case COMMAND_LOCATION_DEV_CFG_RSP:
   3884                if ( pCBs->pfnLocationRsp )
   3885                {
   3886                  rsp.un.devCfg.status = *pData++;
   3887                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3888                  {
   3889                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3890                    pData += 2;
   3891                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3892                    pData += 2;
   3893                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3894                    pData += 2;
   3895                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3896                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3897          
   3898                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3899                    rsp.cmdID = pInMsg->hdr.commandID;
   3900          
   3901                    // Notify the Application
   3902                    pCBs->pfnLocationRsp( &rsp );
   3903                  }
   3904                }
   3905                break;
   3906          
   3907              case COMMAND_LOCATION_DATA_RSP:
   3908              case COMMAND_LOCATION_DATA_NOTIF:
   3909              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3910                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3911                break;
   3912          
   3913              case COMMAND_LOCATION_RSSI_PING:
   3914                if ( pCBs->pfnLocationRsp )
   3915                {
   3916                  rsp.un.locationType = *pData;
   3917          
   3918                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3919                  rsp.cmdID = pInMsg->hdr.commandID;
   3920          
   3921                  // Notify the Application
   3922                  pCBs->pfnLocationRsp( &rsp );
   3923                }
   3924                break;
   3925          
   3926              default:
   3927                stat = ZFailure;
   3928                break;
   3929            }
   3930          
   3931            return ( stat );
   3932          }
   3933          #endif // ZCL_LOCATION
   3934          
   3935          #ifdef ZCL_SCENES
   3936          #if !defined ( ZCL_STANDALONE )
   3937          /*********************************************************************
   3938           * @fn      zclGeneral_ScenesInitNV
   3939           *
   3940           * @brief   Initialize the NV Scene Table Items
   3941           *
   3942           * @param   none
   3943           *
   3944           * @return  number of scenes
   3945           */
   3946          static uint8 zclGeneral_ScenesInitNV( void )
   3947          {
   3948            uint8  status;
   3949            uint16 size;
   3950          
   3951            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3952                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3953          
   3954            status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3955          
   3956            if ( status != ZSUCCESS )
   3957            {
   3958              zclGeneral_ScenesSetDefaultNV();
   3959            }
   3960          
   3961            return status;
   3962          }
   3963          #endif // ZCL_STANDALONE
   3964          
   3965          #if !defined ( ZCL_STANDALONE )
   3966          /*********************************************************************
   3967           * @fn          zclGeneral_ScenesSetDefaultNV
   3968           *
   3969           * @brief       Write the defaults to NV
   3970           *
   3971           * @param       none
   3972           *
   3973           * @return      none
   3974           */
   3975          static void zclGeneral_ScenesSetDefaultNV( void )
   3976          {
   3977            nvGenScenesHdr_t hdr;
   3978          
   3979            // Initialize the header
   3980            hdr.numRecs = 0;
   3981          
   3982            // Save off the header
   3983            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3984          }
   3985          #endif // ZCL_STANDALONE
   3986          
   3987          #if !defined ( ZCL_STANDALONE )
   3988          /*********************************************************************
   3989           * @fn          zclGeneral_ScenesWriteNV
   3990           *
   3991           * @brief       Save the Scene Table in NV
   3992           *
   3993           * @param       none
   3994           *
   3995           * @return      none
   3996           */
   3997          static void zclGeneral_ScenesWriteNV( void )
   3998          {
   3999            nvGenScenesHdr_t hdr;
   4000            zclGenSceneItem_t *pLoop;
   4001            zclGenSceneNVItem_t item;
   4002          
   4003            hdr.numRecs = 0;
   4004          
   4005            // Look for end of list
   4006            pLoop = zclGenSceneTable;
   4007            while ( pLoop )
   4008            {
   4009              // Build the record
   4010              item.endpoint = pLoop->endpoint;
   4011              zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   4012          
   4013              // Save the record to NV
   4014              zcl_nv_write( ZCD_NV_SCENE_TABLE,
   4015                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   4016                              sizeof ( zclGenSceneNVItem_t ), &item );
   4017          
   4018              hdr.numRecs++;
   4019          
   4020              pLoop = pLoop->next;
   4021            }
   4022          
   4023            // Save off the header
   4024            zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   4025          }
   4026          #endif // ZCL_STANDALONE
   4027          
   4028          #if !defined ( ZCL_STANDALONE )
   4029          /*********************************************************************
   4030           * @fn          zclGeneral_ScenesRestoreFromNV
   4031           *
   4032           * @brief       Restore the Scene table from NV
   4033           *
   4034           * @param       none
   4035           *
   4036           * @return      Number of entries restored
   4037           */
   4038          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   4039          {
   4040            uint16 x;
   4041            nvGenScenesHdr_t hdr;
   4042          
   4043            zclGenSceneNVItem_t item;
   4044            uint16 numAdded = 0;
   4045          
   4046            if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   4047            {
   4048              // Read in the device list
   4049              for ( x = 0; x < hdr.numRecs; x++ )
   4050              {
   4051                if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
   4052                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   4053                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   4054                {
   4055                  // Add the scene
   4056                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   4057                  {
   4058                    numAdded++;
   4059                  }
   4060                }
   4061              }
   4062            }
   4063          
   4064            return ( numAdded );
   4065          }
   4066          #endif // ZCL_STANDALONE
   4067          
   4068          #if !defined ( ZCL_STANDALONE )
   4069          /*********************************************************************
   4070           * @fn          zclGeneral_ScenesInit
   4071           *
   4072           * @brief       Initialize the scenes table
   4073           *
   4074           * @param       none
   4075           *
   4076           * @return      none
   4077           */
   4078          void zclGeneral_ScenesInit( void )
   4079          {
   4080            // Initialize NV items
   4081            zclGeneral_ScenesInitNV();
   4082          
   4083            // Restore the Scene table
   4084            zclGeneral_ScenesRestoreFromNV();
   4085          }
   4086          #endif // ZCL_STANDALONE
   4087          
   4088          #if !defined ( ZCL_STANDALONE )
   4089          /*********************************************************************
   4090           * @fn          zclGeneral_ScenesSave
   4091           *
   4092           * @brief       Save the scenes table
   4093           *
   4094           * @param       none
   4095           *
   4096           * @return      none
   4097           */
   4098          void zclGeneral_ScenesSave( void )
   4099          {
   4100            // Update NV
   4101            zclGeneral_ScenesWriteNV();
   4102          }
   4103          #endif // ZCL_STANDALONE
   4104          
   4105          #endif // ZCL_SCENES
   4106          
   4107          /***************************************************************************
   4108          ****************************************************************************/
   4109          
   4110          #if defined ( INTER_PAN )
   4111            #include "stub_aps.h"
   4112          #endif
   4113          
   4114          /*********************************************************************
   4115           * MACROS
   4116           */
   4117          
   4118          /*********************************************************************
   4119           * CONSTANTS
   4120           */
   4121          
   4122          /*********************************************************************
   4123           * TYPEDEFS
   4124           */
   4125          typedef struct zclClosuresDoorLockCBRec
   4126          {
   4127            struct zclClosuresDoorLockCBRec     *next;
   4128            uint8                                endpoint; // Used to link it into the endpoint descriptor
   4129            zclClosures_DoorLockAppCallbacks_t  *CBs;     // Pointer to Callback function
   4130          } zclClosuresDoorLockCBRec_t;
   4131          
   4132          
   4133          /*********************************************************************
   4134           * GLOBAL VARIABLES
   4135           */
   4136          
   4137          /*********************************************************************
   4138           * GLOBAL FUNCTIONS
   4139           */
   4140          
   4141          /*********************************************************************
   4142           * LOCAL VARIABLES
   4143           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   4144          static zclClosuresDoorLockCBRec_t *zclClosuresDoorLockCBs = (zclClosuresDoorLockCBRec_t *)NULL;
   \                     zclClosuresDoorLockCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
   4145          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   4146          static uint8 zclDoorLockPluginRegisted = FALSE;
   \                     zclDoorLockPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
   4147          
   4148          
   4149          /*********************************************************************
   4150           * LOCAL FUNCTIONS
   4151           */
   4152          static ZStatus_t zclClosures_HdlIncoming( zclIncoming_t *pInMsg );
   4153          static ZStatus_t zclClosures_HdlInSpecificCommands( zclIncoming_t *pInMsg );
   4154          
   4155          static zclClosures_DoorLockAppCallbacks_t *zclClosures_FindDoorLockCallbacks( uint8 endpoint );
   4156          static ZStatus_t zclClosures_ProcessInDoorLockCmds( zclIncoming_t *pInMsg,
   4157                                                              zclClosures_DoorLockAppCallbacks_t *pCBs );
   4158          
   4159          
   4160          /*********************************************************************
   4161           * @fn      zclClosures_RegisterDoorLockCmdCallbacks
   4162           *
   4163           * @brief   Register an applications DoorLock command callbacks
   4164           *
   4165           * @param   endpoint - application's endpoint
   4166           * @param   callbacks - pointer to the callback record.
   4167           *
   4168           * @return  ZMemError if not able to allocate
   4169           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4170          ZStatus_t zclClosures_RegisterDoorLockCmdCallbacks( uint8 endpoint, zclClosures_DoorLockAppCallbacks_t *callbacks )
   \                     zclClosures_RegisterDoorLockCmdCallbacks:
   4171          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   4172            zclClosuresDoorLockCBRec_t *pNewItem;
   4173            zclClosuresDoorLockCBRec_t *pLoop;
   4174          
   4175            // Register as a ZCL Plugin
   4176            if ( !zclDoorLockPluginRegisted )
   \   00000B   90....       MOV       DPTR,#zclDoorLockPluginRegisted
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7021         JNZ       ??zclClosures_RegisterDoorLockCmdCallbacks_0
   4177            {
   4178              zcl_registerPlugin( ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   4179                                  ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK,
   4180                                  zclClosures_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV       ?V2,#`??zclClosures_HdlIncoming::?relay` & 0xff
   \   000014   75....       MOV       ?V3,#(`??zclClosures_HdlIncoming::?relay` >> 8) & 0xff
   \   000017   78..         MOV       R0,#?V2
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7C01         MOV       R4,#0x1
   \   00001E   7D01         MOV       R5,#0x1
   \   000020   7A01         MOV       R2,#0x1
   \   000022   7B01         MOV       R3,#0x1
   \   000024   12....       LCALL     `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
   4181              zclDoorLockPluginRegisted = TRUE;
   \   00002C   90....       MOV       DPTR,#zclDoorLockPluginRegisted
   \   00002F   7401         MOV       A,#0x1
   \   000031   F0           MOVX      @DPTR,A
   4182            }
   4183          
   4184            // Fill in the new profile list
   4185            pNewItem = zcl_mem_alloc( sizeof( zclClosuresDoorLockCBRec_t ) );
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV       R2,#0x5
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV       ?V2,R2
   \   00003B   8B..         MOV       ?V3,R3
   \   00003D   A8..         MOV       R0,?V2
   \   00003F   A9..         MOV       R1,?V3
   4186            if ( pNewItem == NULL )
   \   000041   E8           MOV       A,R0
   \   000042   49           ORL       A,R1
   \   000043   7004         JNZ       ??zclClosures_RegisterDoorLockCmdCallbacks_1
   4187            {
   4188              return ( ZMemError );
   \   000045   7910         MOV       R1,#0x10
   \   000047   8025         SJMP      ??zclClosures_RegisterDoorLockCmdCallbacks_2
   4189            }
   4190          
   4191            pNewItem->next = (zclClosuresDoorLockCBRec_t *)NULL;
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_1:
   \   000049   12....       LCALL     ?Subroutine19 & 0xFFFF
   4192            pNewItem->endpoint = endpoint;
   4193            pNewItem->CBs = callbacks;
   4194          
   4195            // Find spot in list
   4196            if ( zclClosuresDoorLockCBs == NULL )
   \                     ??CrossCallReturnLabel_28:
   \   00004C   90....       MOV       DPTR,#zclClosuresDoorLockCBs
   \   00004F   12....       LCALL     ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000052   90....       MOV       DPTR,#zclClosuresDoorLockCBs
   \   000055   6012         JZ        ??zclClosures_RegisterDoorLockCmdCallbacks_3
   4197            {
   4198              zclClosuresDoorLockCBs = pNewItem;
   4199            }
   4200            else
   4201            {
   4202              // Look for end of list
   4203              pLoop = zclClosuresDoorLockCBs;
   \   000057   E0           MOVX      A,@DPTR
   \   000058   FC           MOV       R4,A
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   8003         SJMP      ??zclClosures_RegisterDoorLockCmdCallbacks_4
   4204              while ( pLoop->next != NULL )
   4205              {
   4206                pLoop = pLoop->next;
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_5:
   \   00005D   EA           MOV       A,R2
   \   00005E   FC           MOV       R4,A
   \   00005F   EB           MOV       A,R3
   4207              }
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_4:
   \   000060   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000063   70F8         JNZ       ??zclClosures_RegisterDoorLockCmdCallbacks_5
   4208          
   4209              // Put new item at end of list
   4210              pLoop->next = pNewItem;
   \   000065   8C82         MOV       DPL,R4
   \   000067   8D83         MOV       DPH,R5
   4211            }
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_3:
   \   000069   12....       LCALL     ?Subroutine20 & 0xFFFF
   4212            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_57:
   \   00006C   7900         MOV       R1,#0x0
   \                     ??zclClosures_RegisterDoorLockCmdCallbacks_2:
   \   00006E   02....       LJMP      ??Subroutine31_0 & 0xFFFF
   4213          }
   4214          
   4215          /*********************************************************************
   4216           * @fn      zclClosures_FindDoorLockCallbacks
   4217           *
   4218           * @brief   Find the DoorLock callbacks for an endpoint
   4219           *
   4220           * @param   endpoint
   4221           *
   4222           * @return  pointer to the callbacks
   4223           */
   4224          static zclClosures_DoorLockAppCallbacks_t *zclClosures_FindDoorLockCallbacks( uint8 endpoint )
   4225          {
   4226            zclClosuresDoorLockCBRec_t *pCBs;
   4227          
   4228            pCBs = zclClosuresDoorLockCBs;
   4229            while ( pCBs )
   4230            {
   4231              if ( pCBs->endpoint == endpoint )
   4232              {
   4233                return ( pCBs->CBs );
   4234              }
   4235              pCBs = pCBs->next;
   4236            }
   4237            return ( (zclClosures_DoorLockAppCallbacks_t *)NULL );
   4238          }
   4239          
   4240          
   4241          /*********************************************************************
   4242           * @fn      zclClosures_HdlIncoming
   4243           *
   4244           * @brief   Callback from ZCL to process incoming Commands specific
   4245           *          to this cluster library or Profile commands for attributes
   4246           *          that aren't in the attribute list
   4247           *
   4248           * @param   pInMsg - pointer to the incoming message
   4249           * @param   logicalClusterID
   4250           *
   4251           * @return  ZStatus_t
   4252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4253          static ZStatus_t zclClosures_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclClosures_HdlIncoming:
   4254          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   4255            ZStatus_t stat = ZSuccess;
   4256          
   4257          #if defined ( INTER_PAN )
   4258            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   4259              return ( stat ); // Cluster not supported thru Inter-PAN
   4260          #endif
   4261            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   5407         ANL       A,#0x7
   \   00000D   6401         XRL       A,#0x1
   \   00000F   7007         JNZ       ??zclClosures_HdlIncoming_0
   4262            {
   4263              // Is this a manufacturer specific command?
   4264              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   4265              {
   4266                stat = zclClosures_HdlInSpecificCommands( pInMsg );
   \   000011                ; Setup parameters for call to function zclClosures_HdlInSpecificCommands
   \   000011   12....       LCALL     `??zclClosures_HdlInSpecificCommands::?relay`; Banked call to: zclClosures_HdlInSpecificCommands
   \   000014   E9           MOV       A,R1
   \   000015   F9           MOV       R1,A
   \   000016   8002         SJMP      ??zclClosures_HdlIncoming_1
   4267              }
   4268              else
   4269              {
   4270                // We don't support any manufacturer specific command.
   4271                stat = ZFailure;
   4272              }
   4273            }
   4274            else
   4275            {
   4276              // Handle all the normal (Read, Write...) commands -- should never get here
   4277              stat = ZFailure;
   \                     ??zclClosures_HdlIncoming_0:
   \   000018   7901         MOV       R1,#0x1
   4278            }
   4279            return ( stat );
   \                     ??zclClosures_HdlIncoming_1:
   \   00001A   02....       LJMP      ?Subroutine2 & 0xFFFF
   4280          }
   4281          
   4282          /*********************************************************************
   4283           * @fn      zclClosures_HdlInSpecificCommands
   4284           *
   4285           * @brief   Callback from ZCL to process incoming Commands specific
   4286           *          to this cluster library
   4287          
   4288           * @param   pInMsg - pointer to the incoming message
   4289           *
   4290           * @return  ZStatus_t
   4291           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4292          static ZStatus_t zclClosures_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclClosures_HdlInSpecificCommands:
   4293          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4294            ZStatus_t stat;
   4295            zclClosures_DoorLockAppCallbacks_t *pDLCBs;
   4296          
   4297          
   4298            // make sure endpoint exists
   4299            pDLCBs = zclClosures_FindDoorLockCallbacks( pInMsg->msg->endPoint );
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   12....       LCALL     ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00000C   E8           MOV       A,R0
   \   00000D   FE           MOV       R6,A
   \   00000E   E9           MOV       A,R1
   \   00000F   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000012   FD           MOV       R5,A
   \   000013   90....       MOV       DPTR,#zclClosuresDoorLockCBs
   \                     ??zclClosures_HdlInSpecificCommands_0:
   \   000016   12....       LCALL     ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000019   E8           MOV       A,R0
   \   00001A   49           ORL       A,R1
   \   00001B   6074         JZ        ??zclClosures_HdlInSpecificCommands_1
   \   00001D   8882         MOV       DPL,R0
   \   00001F   8983         MOV       DPH,R1
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   6D           XRL       A,R5
   \   000025   8882         MOV       DPL,R0
   \   000027   8983         MOV       DPH,R1
   \   000029   70EB         JNZ       ??zclClosures_HdlInSpecificCommands_0
   \   00002B   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00002E   88..         MOV       ?V0,R0
   \   000030   89..         MOV       ?V1,R1
   4300            if ( pDLCBs == NULL )
   \   000032   E8           MOV       A,R0
   \   000033   45..         ORL       A,?V1
   \   000035   605A         JZ        ??zclClosures_HdlInSpecificCommands_1
   4301            {
   4302              return ( ZFailure );
   4303            }
   4304          
   4305          
   4306            switch ( pInMsg->msg->clusterId )
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   F5..         MOV       ?V2,A
   \   000042   A3           INC       DPTR
   \   000043   E0           MOVX      A,@DPTR
   \   000044   F5..         MOV       ?V3,A
   \   000046   78..         MOV       R0,#?V2
   \   000048   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for zclClosures_HdlInSpecificComma_0`:
   \   00004B   0101         DW        257
   \   00004D   01           DB        1
   \   00004E   ....         DW        ??zclClosures_HdlInSpecificCommands_2
   \   000050   ....         DW        ??zclClosures_HdlInSpecificCommands_3
   \   000052   ....         DW        ??zclClosures_HdlInSpecificCommands_4
   4307            {
   4308              case ZCL_CLUSTER_ID_CLOSURES_DOOR_LOCK:
   4309                stat = zclClosures_ProcessInDoorLockCmds( pInMsg, pDLCBs );
   \                     ??zclClosures_HdlInSpecificCommands_3:
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   5408         ANL       A,#0x8
   \   00005D   6048         JZ        ??zclClosures_HdlInSpecificCommands_2
   \   00005F   8A82         MOV       DPL,R2
   \   000061   8B83         MOV       DPH,R3
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   12....       LCALL     ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclClosures_HdlInSpecificComma_1`:
   \   00006E   02           DB        2
   \   00006F   00           DB        0
   \   000070   02           DB        2
   \   000071   ....         DW        ??zclClosures_HdlInSpecificCommands_5
   \   000073   03           DB        3
   \   000074   19           DB        25
   \   000075   ....         DW        ??zclClosures_HdlInSpecificCommands_6
   \   000077   00           DB        0
   \   000078   ....         DW        ??zclClosures_HdlInSpecificCommands_2
   \                     ??zclClosures_HdlInSpecificCommands_5:
   \   00007A   12....       LCALL     ?Subroutine14 & 0xFFFF
   4310                break;
   4311          
   4312              case ZCL_CLUSTER_ID_CLOSURES_WINDOW_COVERING:
   4313          #ifdef ZCL_WINDOWCOVERING
   4314                stat = zclClosures_ProcessInWindowCovering( pInMsg, pWCCBs );
   4315          #endif //ZCL_WINDOWCOVERING
   4316                break;
   4317          
   4318              default:
   4319                stat = ZFailure;
   4320                break;
   4321            }
   \                     ??CrossCallReturnLabel_78:
   \   00007D   6028         JZ        ??zclClosures_HdlInSpecificCommands_2
   \   00007F                ; Setup parameters for indirect call
   \   00007F   8A82         MOV       DPL,R2
   \   000081   8B83         MOV       DPH,R3
   \   000083   A3           INC       DPTR
   \   000084   A3           INC       DPTR
   \   000085   A3           INC       DPTR
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00008E   F9           MOV       R1,A
   \   00008F   800B         SJMP      ??zclClosures_HdlInSpecificCommands_7
   \                     ??zclClosures_HdlInSpecificCommands_1:
   \   000091   7901         MOV       R1,#0x1
   \   000093   8016         SJMP      ??zclClosures_HdlInSpecificCommands_8
   \                     ??zclClosures_HdlInSpecificCommands_6:
   \   000095   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000098   600D         JZ        ??zclClosures_HdlInSpecificCommands_2
   \   00009A                ; Setup parameters for indirect call
   \   00009A   7900         MOV       R1,#0x0
   \                     ??zclClosures_HdlInSpecificCommands_7:
   \   00009C   8C82         MOV       DPL,R4
   \   00009E   8D83         MOV       DPH,R5
   \   0000A0   12....       LCALL     ?CALL_IND
   \   0000A3   E9           MOV       A,R1
   \   0000A4   FC           MOV       R4,A
   \   0000A5   8002         SJMP      ??zclClosures_HdlInSpecificCommands_4
   \                     ??zclClosures_HdlInSpecificCommands_2:
   \   0000A7   7C01         MOV       R4,#0x1
   4322          
   4323            return ( stat );
   \                     ??zclClosures_HdlInSpecificCommands_4:
   \   0000A9   EC           MOV       A,R4
   \   0000AA   F9           MOV       R1,A
   \                     ??zclClosures_HdlInSpecificCommands_8:
   \   0000AB   02....       LJMP      ??Subroutine31_0 & 0xFFFF
   4324          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   8983         MOV       DPH,R1
   \   000005                REQUIRE ??Subroutine38_0
   \   000005                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_RegisterCmdCallbacks::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentify::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentify

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyEZModeInvoke::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyEZModeInvoke

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyUpdateCommState::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyUpdateCommState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_SendIdentifyQueryResponse::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyQueryResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlIncoming::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_HdlInSpecificCommands::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInGroupsClient::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInGroupsClient

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclGeneral_ProcessInScenesClient::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInScenesClient

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclClosures_RegisterDoorLockCmdCallbacks::?re`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclClosures_RegisterDoorLockCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclClosures_HdlIncoming::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclClosures_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zclClosures_HdlInSpecificCommands::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclClosures_HdlInSpecificCommands
   4325          
   4326          /*********************************************************************
   4327           * @fn      zclClosures_ProcessInDoorLockCmds
   4328           *
   4329           * @brief   Process in the received DoorLock Command.
   4330           *
   4331           * @param   pInMsg - pointer to the incoming message
   4332           * @param   pCBs - pointer to the Application callback functions
   4333           *
   4334           * @return  ZStatus_t
   4335           */
   4336          static ZStatus_t zclClosures_ProcessInDoorLockCmds( zclIncoming_t *pInMsg,
   4337                                                              zclClosures_DoorLockAppCallbacks_t *pCBs )
   4338          {
   4339            ZStatus_t stat;
   4340          
   4341            // Client-to-Server
   4342            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   4343            {
   4344              stat = ZFailure;
   4345            }
   4346            // Server-to-Client
   4347            else
   4348            {
   4349              switch(pInMsg->hdr.commandID)
   4350              {
   4351                case COMMAND_CLOSURES_LOCK_DOOR_RSP:
   4352                case COMMAND_CLOSURES_UNLOCK_DOOR_RSP:
   4353                case COMMAND_CLOSURES_TOGGLE_DOOR_RSP:
   4354                  if ( pCBs->pfnDoorLockRsp )
   4355                  {
   4356                    return ( pCBs->pfnDoorLockRsp( pInMsg, pInMsg->pData[0] ) );
   4357                  }
   4358                case COMMAND_CLOSURES_UNLOCK_WITH_TIMEOUT_RSP:
   4359                case COMMAND_CLOSURES_GET_LOG_RECORD_RSP:
   4360                case COMMAND_CLOSURES_SET_PIN_CODE_RSP:
   4361                case COMMAND_CLOSURES_GET_PIN_CODE_RSP:
   4362                case COMMAND_CLOSURES_CLEAR_PIN_CODE_RSP:
   4363                case COMMAND_CLOSURES_CLEAR_ALL_PIN_CODES_RSP:
   4364                case COMMAND_CLOSURES_SET_USER_STATUS_RSP:
   4365                case COMMAND_CLOSURES_GET_USER_STATUS_RSP:
   4366                case COMMAND_CLOSURES_SET_WEEK_DAY_SCHEDULE_RSP:
   4367                case COMMAND_CLOSURES_GET_WEEK_DAY_SCHEDULE_RSP:
   4368                case COMMAND_CLOSURES_CLEAR_WEEK_DAY_SCHEDULE_RSP:
   4369                case COMMAND_CLOSURES_SET_YEAR_DAY_SCHEDULE_RSP:
   4370                case COMMAND_CLOSURES_GET_YEAR_DAY_SCHEDULE_RSP:
   4371                case COMMAND_CLOSURES_CLEAR_YEAR_DAY_SCHEDULE_RSP:
   4372                case COMMAND_CLOSURES_SET_HOLIDAY_SCHEDULE_RSP:
   4373                case COMMAND_CLOSURES_GET_HOLIDAY_SCHEDULE_RSP:
   4374                case COMMAND_CLOSURES_CLEAR_HOLIDAY_SCHEDULE_RSP:
   4375                case COMMAND_CLOSURES_SET_USER_TYPE_RSP:
   4376                case COMMAND_CLOSURES_GET_USER_TYPE_RSP:
   4377                case COMMAND_CLOSURES_SET_RFID_CODE_RSP:
   4378                case COMMAND_CLOSURES_GET_RFID_CODE_RSP:
   4379                case COMMAND_CLOSURES_CLEAR_RFID_CODE_RSP:
   4380                case COMMAND_CLOSURES_CLEAR_ALL_RFID_CODES_RSP:
   4381                  if ( pCBs->pfnDoorLockRsp )
   4382                  {
   4383                    return ( pCBs->pfnDoorLockRsp( pInMsg, 0x0 ) );
   4384                  }
   4385              }
   4386              return ( ZCL_STATUS_FAILURE );
   4387            }
   4388          
   4389            return ( stat );
   4390          }
   4391          
   4392          
   4393          /********************************************************************************************
   4394          *********************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     12   zclClosures_HdlInSpecificCommands
      2      0   zclClosures_HdlIncoming
        2      0   -> zclClosures_HdlInSpecificCommands
      1     14   zclClosures_RegisterDoorLockCmdCallbacks
        0     12   -> osal_mem_alloc
        0     14   -> zcl_registerPlugin
      0     14   zclGeneral_HdlInSpecificCommands
        0     14   -> zclGeneral_ProcessInGroupsClient
        0     14   -> zclGeneral_ProcessInScenesClient
      2      0   zclGeneral_HdlIncoming
        2      0   -> zclGeneral_HdlInSpecificCommands
      1     65   zclGeneral_ProcessInGroupsClient
        0     48   -> osal_mem_alloc
        0     48   -> osal_mem_free
        0     51   -> osal_memcpy
        0     48   -> osal_memset
      1    103   zclGeneral_ProcessInScenesClient
        0     86   -> osal_mem_alloc
        0     86   -> osal_mem_free
        0     89   -> osal_memcpy
        0     86   -> osal_memset
      1     14   zclGeneral_RegisterCmdCallbacks
        0     12   -> osal_mem_alloc
        0     14   -> zcl_registerPlugin
      1     25   zclGeneral_SendIdentify
        0     23   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentifyEZModeInvoke
        0     24   -> zcl_SendCommand
      1     25   zclGeneral_SendIdentifyQueryResponse
        0     23   -> zcl_SendCommand
      1     27   zclGeneral_SendIdentifyUpdateCommState
        0     25   -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine31_0
       8  ??Subroutine32_0
       5  ??Subroutine33_0
       5  ??Subroutine34_0
       8  ??Subroutine35_0
       5  ??Subroutine36_0
       8  ??Subroutine37_0
       8  ??Subroutine38_0
       3  ?Subroutine0
      29  ?Subroutine1
       6  ?Subroutine10
      18  ?Subroutine11
      18  ?Subroutine12
       5  ?Subroutine13
       5  ?Subroutine14
       4  ?Subroutine15
       6  ?Subroutine16
       3  ?Subroutine17
      13  ?Subroutine18
      30  ?Subroutine19
       7  ?Subroutine2
       1  ?Subroutine20
      13  ?Subroutine21
      12  ?Subroutine22
      11  ?Subroutine23
      11  ?Subroutine24
      12  ?Subroutine25
      12  ?Subroutine26
      16  ?Subroutine27
      10  ?Subroutine28
      10  ?Subroutine29
       8  ?Subroutine3
       6  ?Subroutine30
      13  ?Subroutine4
       8  ?Subroutine5
       8  ?Subroutine6
       7  ?Subroutine7
       7  ?Subroutine8
       6  ?Subroutine9
       2  zclClosuresDoorLockCBs
     174  zclClosures_HdlInSpecificCommands
       6  zclClosures_HdlInSpecificCommands::?relay
      29  zclClosures_HdlIncoming
       6  zclClosures_HdlIncoming::?relay
     113  zclClosures_RegisterDoorLockCmdCallbacks
       6  zclClosures_RegisterDoorLockCmdCallbacks::?relay
       1  zclDoorLockPluginRegisted
       2  zclGenCBs
       1  zclGenPluginRegisted
     322  zclGeneral_HdlInSpecificCommands
       6  zclGeneral_HdlInSpecificCommands::?relay
      26  zclGeneral_HdlIncoming
       6  zclGeneral_HdlIncoming::?relay
     504  zclGeneral_ProcessInGroupsClient
       6  zclGeneral_ProcessInGroupsClient::?relay
     586  zclGeneral_ProcessInScenesClient
       6  zclGeneral_ProcessInScenesClient::?relay
     112  zclGeneral_RegisterCmdCallbacks
       6  zclGeneral_RegisterCmdCallbacks::?relay
      83  zclGeneral_SendIdentify
       6  zclGeneral_SendIdentify::?relay
     108  zclGeneral_SendIdentifyEZModeInvoke
       6  zclGeneral_SendIdentifyEZModeInvoke::?relay
      83  zclGeneral_SendIdentifyQueryResponse
       6  zclGeneral_SendIdentifyQueryResponse::?relay
     120  zclGeneral_SendIdentifyUpdateCommState
       6  zclGeneral_SendIdentifyUpdateCommState::?relay

 
 2 630 bytes in segment BANKED_CODE
    72 bytes in segment BANK_RELAYS
     6 bytes in segment XDATA_Z
 
    72 bytes of CODE     memory
 2 630 bytes of HUGECODE memory
     6 bytes of XDATA    memory

Errors: none
Warnings: 1
